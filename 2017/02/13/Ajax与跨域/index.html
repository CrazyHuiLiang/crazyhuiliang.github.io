<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="技术笔记 前端开发"><title>编程小记</title><link rel="stylesheet" href="/styles/layout-bundle.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3ee29108db650b60a69ef622a9cbefeb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="编程小记" type="application/atom+xml">
</head><body><div class="main"><link rel="stylesheet" href="/styles/post-bundle.css"><div class="post-page"><h1>Ajax与跨域</h1><p class="create-time">发布时间：2017/02/13</p><article class="content"><p><code>Ajax</code>（Asynchronous JavaScript and XML）中文名称：异步JavaScript与XML。由于其可以在不刷新网站页面的的情况下获取新的数据，且还支持同步和异步两种方式（使用方便），而被广泛应用于网站前端，<code>Ajax</code>名称中的XML含义只因XML曾一度是互联网上存储和传输结构化数据的标准，其获取的数据格式不一定是XML。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>在Ajax出现之前，网站需要和后台交互惯用的方法是通过表单提交，在html文件中使用<code>&lt;form&gt;</code>标签，通常一个请求就是一个表单提交。表单提交有一个特点就是，当用户点击‘submit’按钮后（表单提交的请求发出）浏览器就会刷新页面，当前网页不会接收请求的具体结果，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。比如我们经常会遇到的场景，在登录页面，我们输入帐号和密码，点击登录，如果登录成功，页面就会跳转到网站首页或者个人信息页面，如果输入的帐号或者密码是错误的，通常页面会再次跳转到登录页面提示我们帐号错误或者密码错误，需要重新输入，重新登录。</p><p>而当我们有了<code>Ajax</code>之后，我们就可以使用JavaScript发送请求，再由JavaScript更新DOM，用户体验是数据请求时仍然停留在当前页面，但是数据却可以不断地更新。比较典型的例子就是谷歌地图，打开谷歌地图后，我们可以用鼠标拖动地图，然后新的区域的地图在不需要页面刷新的情况下就可以展现出来。</p><p>通过以上对比我们可以看出有了<code>Ajax</code>之后我们的网页的体验，和速度确实增幅不少。用JavaScript写一个完整的<code>Ajax</code>代码并不复杂，在现代浏览器上写Ajax主要依靠XMLHttpRequest对象。</p><p>下面是一个<code>DOM Level 0</code>风格的Ajax的代码，每行代码后面标注了其含义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册请求状态发生变化的回调，状态发生变化时，函数会被调用</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;          <span class="comment">// readyState为4代表请求成功完成</span></span><br><span class="line">        <span class="comment">// 在这里可以执行请求完成的操作</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">status</span>);         <span class="comment">// status：响应的HTTP状态</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>);     <span class="comment">// statusText：响应的HTTP状态描述 </span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);   <span class="comment">// responseText：响应体返回的文本</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseXML</span>);    <span class="comment">// responseXML：如果响应的内容是&quot;text/xml&quot;或&quot;application/xml&quot;，字段的值为包含响应数据的XML DOM文档</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;MyHeader&quot;</span>)); <span class="comment">// getResponseHeader()方法从xhr对象获取响应头部，只要传入获取头部的名称即可</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getAllResponseHeaders</span>());       <span class="comment">// getAllResponseHeaders()方法会返回包含所有响应头部的字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open()方法支持3个参数：请求类型(&quot;get&quot;,&quot;post&quot;,&quot;put&quot;等)、请求URL，以及表示请求是否异步的布尔值。</span></span><br><span class="line"><span class="comment">// URL可以是相对地址也可以是绝对地址，查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有的名/值都必须以&amp;分割</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api?name1=value1&amp;name2=value2&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setRequestHeader方法可以设置请求头，接收两个参数：头部字段的名词和值。为了确保请求头被发送，必须在open()之后、send()之前调用setRequestHeader()</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;MyHeader&#x27;</span>, <span class="string">&#x27;MyValue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义好请求后，必须使用send()方法发送请求</span></span><br><span class="line"><span class="comment">// send()方法接收一个参数，作为请求体发送的数据。</span></span><br><span class="line"><span class="comment">// 如果模拟表单提交，第一步需要设置请求头 Content-Type为&quot;application/x-www-formurlencoded&quot;，数据需要和url的search部分一样组织</span></span><br><span class="line"><span class="comment">// 如果发送JSON数据，需要设置请求头 Content-Type为&quot;application/json&quot;，数据为json格式的字符串</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">// 在收到响应之前如果想要取消异步请求，可以调用abort()方法</span></span><br><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><h4 id="xhr-readyState"><a href="#xhr-readyState" class="headerlink" title="xhr.readyState"></a>xhr.readyState</h4><p>属性有如下可能的值</p><ul><li>0：未初始化（Uninitialized），尚未调用open()方法</li><li>1：已打开（Open）。已调用open()方法，尚未调用send()方法</li><li>2：已发送(Send)。已调用send()方法，尚未收到响应</li><li>3：接收中（Receiving）。已收到部分响应</li><li>4：完成（Complete）。已经收到了所有响应</li></ul><p>对于低版本的IE，需要换一个ActiveXObject对象，其使用方法和XMLHttpRequest一般无二，在这里就不再多举例子。</p><h3 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h3><p><code>XMLHttpRequest Level 1</code>只是把已存在的XHR对象的实现细节明确了一下，<code>XMLHttpRequest Level 2</code>又进一步发展了XHR对象。</p><h4 id="FormData类型"><a href="#FormData类型" class="headerlink" title="FormData类型"></a>FormData类型</h4><p>FormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过直接给FormData构造函数传入一个表单元素，也可以将表单中的数据作为键值对填充进去</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与表单类似格式的数据然后通过XHR发送</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Nicholas&#x27;</span>); <span class="comment">// append()方法接收两个参数：键和值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了FormData实例，可以直接传给xhr对象的send()方法</span></span><br><span class="line">xhr.<span class="title function_">send</span>(data); <span class="comment">// xhr为XMLHttpRequest的实例</span></span><br></pre></td></tr></table></figure><p>使用FormData的另一个方便之处是不再需要给xhr设置任何请求头部了，xhr对象能够识别作为FormData实例传入的数据类型并自动配置响应头部。</p><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p><code>XMLHttpRequest Level 2</code>中规范了xhr对象增加一个<code>timeout</code>属性和<code>timeout</code>事件，给<code>timeout</code>属性设置一个时间（单位ms），且在该时间过后没有收到响应时，xhr对象就会触发<code>timeout</code>事件。</p><h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType()方法"></a>overrideMimeType()方法</h4><p><code>XMLHttpRequest Level 2</code>中规范了xhr对象引入了 overrideMimeType()方法用于重写xhr响应的MIME类型，因为响应返回的MIME类型决定了xhr对象如何处理响应，所以覆盖了响应返回的类型及影响了响应的解析。假设服务器发送了XML数据，但响应头设置了MIME类型是<code>text/plain</code>。结果会导致虽然数据是XML，但responseXML的属性值是null，调用<code>overrideMimeType(&#39;text/xml&#39;)</code>可以保证响应当成XML而不是纯文本处理。</p><p>为了正确覆盖响应的MIME类型，必须在调用send()之前调用overrideMimeType()。</p><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p><code>Progress Events</code>是W3C的工作草案，定义了客户端-服务器端通信。这些事件最初只针对xhr，现在也推广到了其他类似API。有以下6个进度相关的事件。</p><ul><li>loadstart: 在接收到响应的第一个字节时触发</li><li>progress：在接收响应期间反复触发<ul><li><code>onprogress</code>事件处理程序都会收到event对象，其target属性是xhr对象，且包含3个额外属性<ul><li>lengthComputable: 是一个布尔值，表示进度信息是否可用</li><li>position：是接收到的字节数</li><li>totalSize：是响应的Content-Length头部定义的总字节数</li></ul></li><li>为了保证正确执行，必须在调用open()之前添加<code>onprogress</code>事件处理程序</li></ul></li><li>error：请求出错时触发</li><li>abort：在调用abort()终止连接时触发</li><li>load：在成功接收完响应时触发</li><li>loadend：在通信完成时，且在error、abort或load之后触发</li></ul><p>每次请求都会</p><ul><li>首先触发loadstart事件</li><li>之后是一个或多个progress事件</li><li>接着是error、abort或load中的一个</li><li>最后是已loadend事件结束</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><code>Ajax</code>除了使用方便等优点外，也有一些限制，浏览器出于安全考虑有着同源策略，默认只能访问同源的资源。</p><p>同源是指两个页面拥有相同的协议（protocol），和主机(host)，端口（port），那么这两个页面就属于同一个源（origin）。</p><p>完全不允许跨域访问对于web的发展也是一个严重的制约，大约有为以下几种可以实现跨域请求：</p><h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，目前已基本淘汰。</p><h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p><code>图像ping</code>，我们知道，一个网页可以从任何网页中加载图像，没有跨域的限制，因此我们就可以动态的创建图像，使用它们的<code>onload</code>和<code>onerrer</code>事件处理程序来确定是否请求是否完成。</p><p>这种方式多用于与服务器进行简单、单向的跨域通信的一种方式（比如日志上报）。请求的数据是通过查询字符串形式发送的，而响应通常是一个位图图片，或者204的状态码，通过图像ping，浏览器得不到任何具体的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结束&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;http:127.0.0.2:8888/report?function=login&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里创建了一个image的实例，然后注册<code>onload</code>和<code>onerror</code>的监听，这样无论结果如何，只要请求完成，就能得到通知。当我们为img指定src开始，一个带着function＝login参数的请求就被发了出去。</p><p>这种请求方式有两个主要的缺点，一是只能发送GET请求，二是无法访问响应文本。因此只能用于浏览器与服务器间的单向通信。再多分析一下，图像ping实际上是利用了<img>标签可以执行跨域请求的功能，换句话说，是Dom有跨域请求的功能，想明白这一点估计也就能想到，是不是其他的一些需要引用资源的标签是否也可以实现同样的功能，答案是确定的。类似于<code>&lt;img&gt;</code>还有<code>&lt;link&gt;</code>， <code>&lt;video&gt;</code>，<code>&lt;audio&gt;</code>，<code>&lt;object&gt;</code>，<code>&lt;embed&gt;</code>，<code>&lt;applet&gt;</code>，<code>&lt;iframe&gt;</code>等。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>JSONP</code>是”JSON with padding”的简写，是web服务上流行的一种JSON变体。</p><p>以一个场景为例，比如我们需要获取用户的基本信息，假如我们需要获取用户的用户名，性别和年龄三个字段。<br>以接口为<code>http:127.0.0.2:8888/userInfo</code>，我们需要的数据为<code>&#123;&#39;name&#39;:&#39;Ajax&#39;,&#39;sex&#39;:&#39;female&#39;,&#39;age&#39;:&#39;18&#39;&#125;</code>。</p><p><code>JSONP</code>实际上是利用了浏览器允许跨域引用JavaScript资源。 我们需要首先在页面中准备好回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + data.<span class="property">name</span> + <span class="string">&#x27;,i am&#x27;</span> + data.<span class="property">age</span> + <span class="string">&#x27;years old&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建script标签，并将我们需要请求的url后面跟上请求参数<code>callback</code>等于我们预先准备好的回调函数<code>handleCallback</code>，并将script标签插入文档中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">js.<span class="property">src</span> = <span class="string">&#x27;http:127.0.0.2:8888/userInfo?callback=handleCallback&#x27;</span>;</span><br><span class="line">head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>script标签插入文档后，浏览器就会如同加载js代码一样，以<code>get</code>请求的方式去获取src所链接的资源，当后台收到请求后，可以得到请求参数callback的值<code>handleCallback</code>，后台需要将数据包装到<code>handleCallback()</code>中进行返回，看起来和JSON一样，只是被包在一个函数调用里，同时需要Content-type设置为<code>application/javascript</code>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleCallback</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Ajax&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;18&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>当浏览器收到数据后会理所应当的认为返回数据是一段js代码，运行这段代码，恰好就是调用了我们前面预先准备好的函数<code>handleCallback</code>，将我们真正需要传输的数据作为参数传入了回调函数。 这样就完成了跨域加载数据，也是因为<code>JSONP</code>是利用了script标签可以跨域加载资源的这一特点，让请求通过加载脚本的方式进行的，而加载脚本只有<code>get</code>请求一种方式，所以JSONP也只能用使用get请求，并且要求返回数据封装成JavaScript的调用。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨资源共享（CORS）全称<code>Cross-Origin Resource Sharing</code>，规范定义了浏览器与服务器应该如何实现跨源通信。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p><p>比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是<code>text/plain</code>。在发送该请求时，会给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是Origin头部的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果服务器认为这个请求可以接受，就在<code>Access-Control-Allow-Origin</code>头部中回发相同的源信息（如果是公共资源，可以回发<code>*</code>）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果没有这个头部，或者有这个头部，但源信息不匹配，浏览器则不会响应浏览器请求。</p><p>出于安全考虑，跨域xhr对象存在一些限制</p><ul><li>不能使用setRequestHeader() 设置自定义头部</li><li>请求和响应都不携带cookie</li><li>getAllResponseHeaders()方法始终返回空字符串</li></ul><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>CORS通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部，在发送跨域请求时会向服务器发送一个”预检”请求，这个请求使用OPTIONS方法发送并包含以下头部</p><ul><li>Origin：与请求相同</li><li>Access-Control-Request-Method: 请求希望使用的方法</li><li>Access-Control-Request-Headers:要使用的自定义头部列表(可选，以逗号分隔)</li></ul><p>预检请求发送后，服务器可以确定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器沟通这些信息</p><ul><li>Access-Control-Allow-Origin: 与请求头中的Origin相同</li><li>Access-Control-Allow-Methods: 允许的方法（逗号分隔的列表）</li><li>Access-Control-Allow-Headers: 服务器允许的头部（逗号分隔的列表）</li><li>Access-Control-Max-Age: 预存预检请求的秒数</li></ul><p>预检请求返回后，结果会按照响应中指定的时间缓存一段时间，这段时间内这类请求不需要再额外发送一次HTTP请求。</p><h4 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h4><p>默认情况下，跨源请求不提供凭证（cookie、HTTP认证和客户端SSL证书）。可以通过将xhr的<code>withCredentials</code>设置为true来表明请求会发送凭证。如果服务器允许携带凭证的请求，那么可以在响应中包含如下HTTP头部：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给JavaScript（responseText是空字符串，status是0，onerror()被调用。</p><p>服务器也可以在预检请求的响应中发送这个HTTP头部，已表明这个源允许发送凭据请求。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>用<code>nginx</code>、<code>apache</code>做反向代理，也是一种克服同源策略限制的方式。只需要修改<code>nginx／apache</code>的配置即可解决跨域问题，对于一个服务，可以通过配置多个路径前缀来转发<code>http/https</code>请求到多个目标服务。这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。</p><p>我们拿使用nginx设置反向代理来举一个例子： 假设我们我们当前的站点是<code>www.a.com</code>，我们需要访问的资源是: <code>http://www.b.com/course/api/list</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    server_name www.a.com;</span><br><span class="line">    server_name_in_redirect off;</span><br><span class="line">    root /a;</span><br><span class="line">    location /course/api/list &#123;</span><br><span class="line">        proxy_pass http://www.b.com/course/api/list;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段nginx配置，前6行是一些为了开启<code>www.a.com</code>站点的服务所写，后面的<code>location</code>所包的一段文字就是开启反向代理的配置，在<code>location</code>后面跟的是我们请求的前缀的监测的规则，在这里我们就直接写了<code>/course/api/list</code>，这些配置设置完成后，假如我们想要在<code>www.a.com</code>访问接口<code>http://www.b.com/course/api/list</code> 只需要在<code>www.a.com</code> 中访问 <code>http://www.a.com/course/api/list</code> 即可，当请求发出后，我们的本地服务器（nginx）发现这个接口与我们上面的反向代理的匹配规则能够匹配，就会把我们的请求自动转发到配置中的<code>proxy_pass</code>上，也就是<code>http://www.b.com/course/api/list</code> ，并把请求的response取回来，跨域完成。因为我们的<code>www.a.com</code>发出的请求的域名和协议和端口都和当前站一样，自然就不会有各种跨域的限制，不管是请求方式，还是cookie自然也就可以正常使用。</p><blockquote><p>参考文献：<br>《JavaScript高级程序设计》</p><p>浏览器的同源策略 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a target="_blank" rel="noopener" href="http://hayageek.com/cross-domain-Ajax-request-jquery">http://hayageek.com/cross-domain-Ajax-request-jquery</a></p><p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a></p><p><a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000</a></p><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/90975/">http://blog.jobbole.com/90975/</a></p></blockquote></article><p class="last-update">最后更新：2022/06/30</p></div><script src="/scripts/post-bundle.js"></script></div><footer class="site-footer"><section><p>欢迎交流</p><address>Email: <a href="mailto:crazyhuiliang@163.com">crazyhuiliang@163.com</a></address><address>Github: <a target="_blank" rel="noopener" href="https://github.com/CrazyHuiLiang">https://github.com/CrazyHuiLiang</a></address></section></footer></body></html>