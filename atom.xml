<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程小记</title>
  <icon>https://www.gravatar.com/avatar/208c3e903a28ee32a6bd45585b847e2b</icon>
  <subtitle>记录所看所学，不断沉淀</subtitle>
  <link href="http://blog.zhanghuiliang.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.zhanghuiliang.cn/"/>
  <updated>2022-06-30T09:25:44.667Z</updated>
  <id>http://blog.zhanghuiliang.cn/</id>
  
  <author>
    <name>CrazyHuiLiang</name>
    <email>crazyhuiliang@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述HTTP(一)</title>
    <link href="http://blog.zhanghuiliang.cn/2020/04/19/%E7%AE%80%E8%BF%B0HTTP-1/"/>
    <id>http://blog.zhanghuiliang.cn/2020/04/19/%E7%AE%80%E8%BF%B0HTTP-1/</id>
    <published>2020-04-19T10:32:54.000Z</published>
    <updated>2022-06-30T09:25:44.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h1><p>世界上的计算机设备从网络协议的角度可以分为两类，一类是被普罗大众使用的PC、手机，在网络中被称为客户端，另一类呢，就是站在软件背后，为众多客户端提供数据，提供服务的设备，被称为服务端。客户端与服务端借助网络协议进行通信，可以说网络协议是他们的信使，其中http协议在应用层协议中使用最为广泛，接下来用多篇短文简述一下http的内容，这是第一篇，从宏观的角度看一眼HTTP。</p><p>从技术角度来看网络存在的目的就一句话：分享资源。图片，视频，文本，网页等都是资源，同样打印机，摄像头等也算是资源，因特网上有非常多种资源，HTTP给每种想要通过Web传输的对象都打上了MIME类型（Multipurpose Internet Mail Extension, 多用途因特网邮件扩展）,MINE是一种文本标记，表示一种资源的类型和一个特定的子类型，中间由斜杠分割。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text/plain  表示普通的ASCII文本文档</span><br><span class="line">text/html   表示html</span><br><span class="line">image/jpeg  表示JPEG格式的图片</span><br><span class="line">application/vnd.ms-powerpoint  表示微软的PowerPoint演示文件</span><br></pre></td></tr></table></figure><p>每个资源都有一个名字，这样客户端就可以说明他们需要的资源是什么了，服务器资源名称被称为统一资源标识符（Uniform Resource Identifier, URI),URI就像邮政地址一样在全世界唯一标识一个资源，URI目前有两种形式：URL（统一资源定位符）和URN（统一资源名），所以我们常说的URL是URI的子集；目前使用最为广泛的是URL，URN现在还是一个实验中的方案。一个完整的URL格式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;flag&gt;</span><br><span class="line"></span><br><span class="line">eg：https://www.17xueba.com/views/w/course_center/course.vpage</span><br></pre></td></tr></table></figure><p>还有一种简短的URL形式 - 相对URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如在 https://www.17xueba.com页面中有一个图片地址可以写成这样：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;images/home.png&quot;&gt;</span><br></pre></td></tr></table></figure><p>相对URL是基于基础URL来计算出来的，基础URL可以显式的提供，也就是html中的BASE标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比如https://www.17xueba.com的页面中有如下标签的话</span><br><span class="line">&lt;base href=&quot;https://www.17xueba.com/assets&quot; /&gt;</span><br><span class="line"></span><br><span class="line">基础URL就是https://www.17xueba.com/assets</span><br><span class="line"></span><br><span class="line">上面的例子中的图片完整地址就是 https://www.17xueba.com/assets/images/home.png</span><br></pre></td></tr></table></figure><p>在没有显式的提供基础URL时，基础URL就是当前文档所在的URL，上面例子中的图片地址就会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.17xueba.com/images/home.png</span><br></pre></td></tr></table></figure><h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><p>现在有了上面的铺垫可以说一下HTTP的数据格式了，我们把HTTP的数据包称为报文，一次完整的HTTP事务可以描述为客户端向服务器发送一条请求报文，服务器返回一个响应报文，HTTP报文都是纯文本，有三部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">起始行     ：请求报文的起始行是用于说明要做什么，响应报文中的起始行说明出现了什么情况</span><br><span class="line">头部信息   ：起始行后面有多个手部字段，用于更细致的描述报文的行为，每个字段包含一个名字和一个值，两者用:分割</span><br><span class="line"></span><br><span class="line">可选的数据 ：可选，可以包含要发给服务器的数据，或者服务器返回给客户端的数据</span><br></pre></td></tr></table></figure><p>报文格式分别是</p><table><thead><tr><th>请求报文</th><th>响应报文</th></tr></thead><tbody><tr><td>method  request-url  version</td><td>version  status  reason-phrase</td></tr><tr><td>headers</td><td>headers</td></tr><tr><td>entity-body</td><td>entity-body</td></tr></tbody></table><h4 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h4><p>访问一起学网校首页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">请求报文是这样的</span><br><span class="line"></span><br><span class="line">GET /index.vpage HTTP/1.1</span><br><span class="line">Host: www.17xueba.com</span><br><span class="line">Accept: text/html</span><br><span class="line"></span><br><span class="line">通过起始行我们可以看到这个报文我们使用了GET方法，请求的地址是 /index.vpage ,使用的协议版本是HTTP/1.1, 通过头部信息我们知道访问的host是 www.17xueba.com， 希望接收 html 格式的数据，可以看到这里的Accept的值就是我们上面提到的MIME类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应报文是这样的</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sun, 19 Apr 2020 13:03:07 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 11510</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">    &lt;!doctype html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;一起学网校（同班同学都在学）&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">通过起始行我们看到响应的报文使用的是HTTP/1.1版本， status 200代表请求成功，下面头部中分别说明了返回内容的MIME类型是html，内容长度有11510，一个空行后接着返回了响应体。</span><br></pre></td></tr></table></figure><h1 id="报文组成部分"><a href="#报文组成部分" class="headerlink" title="报文组成部分"></a>报文组成部分</h1><p>下面我们详细说一下报文的个组成部分都有什么东西</p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>上面例子中展示了一种请求方法GET，HTTP写一种有说明的方法有以下几种</p><table><thead><tr><th>方法</th><th>描述</th><th>是否包含主题</th></tr></thead><tbody><tr><td>GET</td><td>从服务器获取资源</td><td>否</td></tr><tr><td>HEAD</td><td>只从服务器获取资源的首部信息</td><td>否</td></tr><tr><td>POST</td><td>向服务器发送需要处理的数据</td><td>是</td></tr><tr><td>PUT</td><td>将请求的主体部分存储在服务器上</td><td>是</td></tr><tr><td>TRACE</td><td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td><td>否</td></tr><tr><td>OPTIONS</td><td>查找服务器支持的的方法</td><td>否</td></tr><tr><td>DELETE</td><td>从服务器删除一份文档</td><td>否</td></tr></tbody></table><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>HTTP&#x2F;0.9, 1991制定的版本，是一个有很多严重设计缺陷的版本，只支持GET方法，不支持MIME类型，各种HTTP首部，以及版本号</p><p>HTTP&#x2F;1.0，第一个广泛使用的版本，为HTTP添加了版本号，支持了MIME类型，支持了更多的请求方法</p><p>HTTP&#x2F;1.1,是当前使用的最广的版本，删除了一些不好的特性，明确了语义，引入重要的性能优化措施</p><p>HTTP&#x2F;2.0, 关注的是性能大幅优化</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>状态使用3位数字的状态码来区分，目前状态码共有以下5类：</p><table><thead><tr><th>整体范围</th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>100~199</td><td>100 ~ 101</td><td>信息提示</td></tr><tr><td>200~299</td><td>200 ~ 206</td><td>成功</td></tr><tr><td>300~399</td><td>300 ~ 305</td><td>重定向</td></tr><tr><td>400~499</td><td>400 ~ 415</td><td>客户端错误</td></tr><tr><td>500~599</td><td>500 ~ 505</td><td>服务器错误</td></tr></tbody></table><h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>首部分为以下几类</p><ul><li>通用首部：请求和响应都可以用的首部，比如 Date: Sun, 19 Apr 2020 13:06:11 GMT</li><li>请求首部：只有在请求报文中出现，比如 Accept: *</li><li>响应首部：只有在响应中出现，比如 Server: Tengine</li><li>实体首部：用于说明实体主体部分的数据类型，比如 Content-Type: text&#x2F;html; charset&#x3D;utf-8</li><li>扩展首部：自己随便加</li></ul><p>具体都有哪些首部就查文档吧，学习http的首部是学习http的重点，接下来分多篇来写吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;铺垫&quot;&gt;&lt;a href=&quot;#铺垫&quot; class=&quot;headerlink&quot; title=&quot;铺垫&quot;&gt;&lt;/a&gt;铺垫&lt;/h1&gt;&lt;p&gt;世界上的计算机设备从网络协议的角度可以分为两类，一类是被普罗大众使用的PC、手机，在网络中被称为客户端，另一类呢，就是站在软件背后，为众多客</summary>
      
    
    
    
    
    <category term="网络" scheme="http://blog.zhanghuiliang.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游</title>
    <link href="http://blog.zhanghuiliang.cn/2019/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>http://blog.zhanghuiliang.cn/2019/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2019-11-24T09:27:31.000Z</published>
    <updated>2022-06-30T09:25:44.667Z</updated>
    
    <content type="html"><![CDATA[<p>今天尝试阅读我新买的《深入理解计算机系统》,原本以为这会是一本我啃不动的书，尝试阅读后发现这本书将自己一知半解的概念讲解的非常的通透，语言形象且简练，颇有一种相见恨晚的感觉，今天也就阅读了第一章，随手记下了书中讲的几个概念，写出来方便自己回顾吧。</p><h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><p>书中将文件分为两类</p><ul><li>文本文件：由ASCII字符构成的文件（比如hello.c)</li><li>二进制文件：非ASCII字符构成的文件~</li></ul><h2 id="c语言编译过程"><a href="#c语言编译过程" class="headerlink" title="c语言编译过程"></a>c语言编译过程</h2><p>c语言源程序（.c)文件需要经过翻译才可以被执行，翻译的过程有以下4个步骤</p><ul><li>预处理（cpp): 根据.c(文本)文件中#开头的命令修改原始c程序，比如#include &lt;stdio.h&gt;读取系统头文件stdio.h的内容，生成.i(文本）文件</li><li>编译（ccl）：将.i文件翻译.s(文本）汇编代码</li><li>汇编（as）：将.s文件翻译为机器指令.o(二进制)目标文件</li><li>链接（ld）：编译器会提供标准c库中的函数预编译好的.o文件，这一阶段链接器会将这部分内容与我们的.o文件进行合并生成可执行文件,可执行文件可以被加载如内存中，由系统执行</li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>是一个命令行解释器，他输出一个提示符，等待输入一个命令，然后执行这个命令</p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>贯穿整个系统的一组电子管道，他携带信息字节，并负责在各个部件间传递</p><h2 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h2><p>是系统与外界世界的联系通道</p><h2 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h2><p>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据</p><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>中央处理单元（CPU），是解释或执行存储在主存中的指令的引擎。核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC），在任何时刻，PC都指向主存中的某条机器语言指令</p><h2 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h2><p>CPU指令在指令的要求下可能会执行这些操作：</p><ul><li>加载：从主存复制一个字节或一个字到主存的某个位置，以覆盖这个位置上原来的内容</li><li>存储：从寄存器复制一个字节或一个字到主存的某个位置，以覆盖这个位置原来的内容</li><li>操作：把两个寄存器的内容复制到ALU（算术&#x2F;逻辑单元），ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖寄存器中原来的内容</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值</li></ul><h2 id="高速缓存存储器（cache-memory）"><a href="#高速缓存存储器（cache-memory）" class="headerlink" title="高速缓存存储器（cache memory）"></a>高速缓存存储器（cache memory）</h2><p>设计在CPU芯片中，运行速度比主存要快</p><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>所有程序对硬件的操作都必须通过操作系统，操作系统有两个基本功能</p><ol><li>防止硬件被失控的程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</li></ol><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>是操作系统对一个正在运行的程序的抽象</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>是现代操作系统中设计的相对进程更小的执行单元，一个进程中可能会有多个线程，多个线程共享进程的上下文</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>一个抽象概念，它为每个进程提供一个假象，即每个进程都在独占地使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>就是字节序列，仅此而已。每个I&#x2F;O设备，甚至网络，都可以看成文件</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>千里之行始于足下,加油啃掉这本书吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天尝试阅读我新买的《深入理解计算机系统》,原本以为这会是一本我啃不动的书，尝试阅读后发现这本书将自己一知半解的概念讲解的非常的通透，语言形象且简练，颇有一种相见恨晚的感觉，今天也就阅读了第一章，随手记下了书中讲的几个概念，写出来方便自己回顾吧。&lt;/p&gt;
&lt;h2 id=&quot;文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关闭iCloud信息同步进程</title>
    <link href="http://blog.zhanghuiliang.cn/2019/08/10/%E5%85%B3%E9%97%ADiCloud%E4%BF%A1%E6%81%AF%E5%90%8C%E6%AD%A5%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.zhanghuiliang.cn/2019/08/10/%E5%85%B3%E9%97%ADiCloud%E4%BF%A1%E6%81%AF%E5%90%8C%E6%AD%A5%E8%BF%9B%E7%A8%8B/</id>
    <published>2019-08-10T02:21:43.000Z</published>
    <updated>2022-06-30T09:53:30.634Z</updated>
    
    <content type="html"><![CDATA[<p>一天工作结束后，略感疲惫，漫步走进地铁，塞上耳塞进入一个人的世界，《Auld Lang Syne》在身体中缓缓流过，舒缓的节奏、磁性的嗓音、以及让心暖心的歌词让人感觉精神渐渐充盈。反复享受多遍后仍不过瘾，我决定要打印出这个歌词好好学习一下。</p><p>回家后，作为一个家中没有WiFi的贫苦青年，只能用手机开一个 <strong>个人热点</strong> 给mac使用，打开mac，打开音乐播放器，兴致冲冲的找到歌曲，点击播放，然后… 音乐播放了5秒就停住了，等十几秒后再次播放，然后秒秒钟后再次停住，显示加载。一声苦叹，生活苦啊，没有WiFi的孩子苦啊，上不了网啊… 正准备关掉手机热点时发现，手机上显示速度是每秒1M多，纳尼？不对头啊，每秒1M的实际速度不够听一首歌的？</p><p>打开’活动监视器‘检查一下网络，如下图</p><img src="/2019/08/10/%E5%85%B3%E9%97%ADiCloud%E4%BF%A1%E6%81%AF%E5%90%8C%E6%AD%A5%E8%BF%9B%E7%A8%8B/evil.png" class="" title="罪证"><p>不出所料有进程抢占了我的流量资源啊，按照已接收字节倒叙排序，发现一个叫做 <strong>nsurlsessiond</strong> 的进程在疯狂的占用带宽，搜索一下，发现他是macOS 10.10系统新加的中文翻译为“互联互通”的功能，主要用于iCloud的同步数据。</p><p>罪魁祸首就是他了，就目前我的需求来看，苹果的iCloud显然不如我的正常网络访问重要，搜索一下，找到以下命令来关闭 <strong>nsurlsessiond</strong> 的运行、自动启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">launchctl unload /System/Library/LaunchDaemons/com.apple.nsurlstoraged.plist</span><br><span class="line">launchctl unload /System/Library/LaunchAgents/com.apple.nsurlsessiond.plist</span><br><span class="line">sudo launchctl unload /System/Library/LaunchDaemons/com.apple.nsurlsessiond.plist</span><br><span class="line">sudo launchctl unload /System/Library/LaunchDaemons/com.apple.nsurlstoraged.plist</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Shell中执行上面所述命令后报一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operation not permitted while System Integrity Protection is engaged</span><br></pre></td></tr></table></figure><p>看样子这厮还有保护伞，如此的流氓就必须打掉，继续搜索应对措施，发现这是mac系统的一种名为<strong>系统完整性保护</strong>的约束。关闭约束的步骤：</p><ol><li>进入系统的恢复模式（关机，再次开机按住command + r）</li><li>在页面菜单中点击<strong>实用工具</strong>，点击<strong>终端</strong></li><li>执行命令 <code>csrutil disable</code></li><li>关机重启</li></ol><p>OK,现在保护伞关掉了，开机后重新执行上面的关闭 <strong>nsurlsessiond</strong> 命令就可以成功了。</p><h2 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h2><p><strong>系统完整性保护</strong>是系统的一种安全机制，正常情况不建议关闭，如需开启，开启的指令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同样需要在系统的恢复模式执行：</span><br><span class="line">csrutil enable</span><br></pre></td></tr></table></figure><p>同样，日后哪天需要再和 <strong>nsurlsessiond</strong> 共事时，执行下面指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">launchctl load /System/Library/LaunchDaemons/com.apple.nsurlstoraged.plist</span><br><span class="line">launchctl load /System/Library/LaunchAgents/com.apple.nsurlsessiond.plist</span><br><span class="line">sudo launchctl load /System/Library/LaunchDaemons/com.apple.nsurlsessiond.plist</span><br><span class="line">sudo launchctl load /System/Library/LaunchDaemons/com.apple.nsurlstoraged.plist</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><blockquote><p><a href="https://discussionschinese.apple.com/thread/140132285?answerId=140315426322#140315426322">https://discussionschinese.apple.com/thread/140132285?answerId=140315426322#140315426322</a><br><a href="https://www.chadou.me/p/193">https://www.chadou.me/p/193</a><br><a href="https://www.technipages.com/macos-system-integrity-protection">https://www.technipages.com/macos-system-integrity-protection</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一天工作结束后，略感疲惫，漫步走进地铁，塞上耳塞进入一个人的世界，《Auld Lang Syne》在身体中缓缓流过，舒缓的节奏、磁性的嗓音、以及让心暖心的歌词让人感觉精神渐渐充盈。反复享受多遍后仍不过瘾，我决定要打印出这个歌词好好学习一下。&lt;/p&gt;
&lt;p&gt;回家后，作为一个家</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript正则</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/12/JavaScript%E6%AD%A3%E5%88%99/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/12/JavaScript%E6%AD%A3%E5%88%99/</id>
    <published>2019-05-12T10:22:47.000Z</published>
    <updated>2022-06-30T09:25:44.658Z</updated>
    
    <content type="html"><![CDATA[<p>字符串操作在我们编程中是经常会接触到的，正则表达式是一把操作字符串的利器，我们今天就来罗列一下JavaScript正则相关的api。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>JavaScript中提供了字面量和调用RegExp构造函数两种方式来创建正则表达式实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 字面量写法</span><br><span class="line">var expression = / pattern / flags;</span><br></pre></td></tr></table></figure><p>pattern可以是任何正则表达式(包含字符类、限定符、分组、向前查找、反向引用),模式中使用的所有元字符都必须转义。正则表达式中的元字符包括 ( [ { \ ^ $ | ) ? * + . ] }。flags可取以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g: 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</span><br><span class="line">i: 表示不区分大小写（case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写</span><br><span class="line">m: 表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</span><br><span class="line">u: 支持Unicode扩展字符集的匹配（ES6新增）</span><br><span class="line">y: 影响搜索过程的sticky属性,后面会具体介绍（ES6新增）</span><br></pre></td></tr></table></figure><p>使用构造函数时,第一个参数是字符串类型时，相对于字面量写法，如果有需要转义的字符串，相对于字面量写法需要再多一次转义;如果是一个正则表达式时，会对传入的正则表达式进行复制，在ES6之前，不允许传入第二个参数，否则会发生语法错误，在ES6之后，传入的第二个参数会覆盖原正则表达式的标识符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用构造函数</span><br><span class="line">var expression = new RegExp(pattern, flags) </span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>正则表达式具有一些实例属性，我们可以使用下面的表达式依次尝试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 匹配第一个&#x27;bat&#x27;或&#x27;cat&#x27;,不区分大小写</span><br><span class="line">var pattern2 = /[bt]at/i;</span><br><span class="line"></span><br><span class="line">以下属性都使用此表达式</span><br></pre></td></tr></table></figure><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>可以用来判断正则表达式是否具有g标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;global\t\t&#x27;, pattern2.global); // global false</span><br></pre></td></tr></table></figure><h3 id="ignoreCase"><a href="#ignoreCase" class="headerlink" title="ignoreCase"></a>ignoreCase</h3><p>用于判断正则表达式是否具有i标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;ignoreCase\t&#x27;, pattern2.ignoreCase); // ignoreCase true</span><br></pre></td></tr></table></figure><h3 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h3><p>用来确定下一次正则匹配的起始位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;lastIndex\t&#x27;, pattern2.lastIndex); // lastIndex 0</span><br></pre></td></tr></table></figure><h3 id="multiline"><a href="#multiline" class="headerlink" title="multiline"></a>multiline</h3><p>用于判断正则表达式是否具有m标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;multiline\t&#x27;, pattern2.multiline); // multiline false</span><br></pre></td></tr></table></figure><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>返回正则表达式的字面量字符, 在ES6之前会返回包括表达式标识完整的字面量，ES6之后，只返回表达式本身，不包含标识（为获取标识提供了单独的flags属性）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;source\t\t&#x27;, pattern2.source); // source [bt]at</span><br></pre></td></tr></table></figure><h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><p>属性用来判断正则表达式有没有u标识符 (ES6新增)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;unicode&#x27;, pattern2.unicode); // unicode false</span><br></pre></td></tr></table></figure><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>属性来判断表达式是否有y标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;sticky&#x27;, pattern2.sticky); // sticky false</span><br></pre></td></tr></table></figure><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>用于查看正则表达式的所有标识, （ES6新增）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;flags&#x27;, pattern2.flags); // flags i</span><br></pre></td></tr></table></figure><h2 id="正则表达式函数"><a href="#正则表达式函数" class="headerlink" title="正则表达式函数"></a>正则表达式函数</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>正则表达式exec函数执行后，如果字符串不匹配正则表达式，会返回null，可以匹配的话，会返回一个数组对象，数组的第一项为匹配的字符串，其后为捕获组所捕获的字符串，如果表达式中不含捕获组，数组就只有一项数据，该数组对象相对于普通数组会拥有额外的两个属性index和input，index是字符串中匹配字串首字符的下标，input即被校验的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;mom and dad and baby&#x27;;</span><br><span class="line">var pattern = /mom( and dad( and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">if (matches) &#123;</span><br><span class="line">console.log(matches.index); // 0</span><br><span class="line">console.log(matches.input); // mom and dad and baby</span><br><span class="line">console.log(matches[0]); // mom and dad and baby</span><br><span class="line">console.log(matches[1]); //  and dad and baby</span><br><span class="line">console.log(matches[2]); //  and baby</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则中不使用g标志时，每次调用exec函数都会返回第一个匹配项的信息,表达式的lastIndex属性每次都返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /.at/;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 0</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 0</span><br></pre></td></tr></table></figure><p>正则中使用g标志时，每次调用exec后都会返回新的匹配项，直到没有匹配项,表达式的lastIndex属性每次都调用过exec都会增加，变为上次匹配字符的后一字符的下标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.at/g;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 3</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 5 &#x27;bat&#x27; 8</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 10 &#x27;sat&#x27; 13</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 15 &#x27;fat&#x27; 18</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>正则表达式中的test方法接收一个字符串参数，当前模式与参数匹配的话返回true，否则返回false，test方法经常用于只想要检测字符是否符合规则，不关心字符内容的场景，常用于对用户输入进行校验。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;000-00-0000&#x27;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br></pre></td></tr></table></figure><p>值得注意的是，表达式中有g标识时，同exec函数一样，每次执行会从上次匹配结尾处向后继续尝试匹配，完成最后一次匹配后的下一次调用将会返回false，再下一次调用会重新从字符串开始处进行模式匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;bad dad eazy go mad.&#x27;;</span><br><span class="line">var pattern = /.ad/g;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // false</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最后一次正则表达式操作而变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;this is a wonderful year!&#x27;;</span><br><span class="line">var pattern = /(...)der(...)/gi;</span><br><span class="line">if (pattern.test(text)) &#123;</span><br><span class="line">// 最近一次要匹配的字符串（Opera未实现）</span><br><span class="line">console.log(RegExp.input); // this is a wonderful year!</span><br><span class="line">console.log(RegExp.$_); // this is a wonderful year!</span><br><span class="line"></span><br><span class="line">// 最近的一次匹配（Opera未实现）</span><br><span class="line">console.log(RegExp.lastMatch); // wonderful</span><br><span class="line">console.log(RegExp[&#x27;$&amp;&#x27;]) // wonderful</span><br><span class="line"></span><br><span class="line">// 最近一次匹配的捕获组（Opera未实现）</span><br><span class="line">console.log(RegExp.lastParen); // ful</span><br><span class="line">console.log(RegExp[&quot;$+&quot;]); // full</span><br><span class="line"></span><br><span class="line">// 所有表达式都使用多行模式,boolean类型（nodejs,IE和Opera未实现）</span><br><span class="line">console.log(RegExp.multiline);</span><br><span class="line">console.log(RegExp[&#x27;$*&#x27;]);</span><br><span class="line"></span><br><span class="line">// input字符串中lastMatch之前的文本(Opera不支持短属性名）</span><br><span class="line">console.log(RegExp.leftContext); // this is a </span><br><span class="line">console.log(RegExp[&quot;$`&quot;]); // this is a </span><br><span class="line"></span><br><span class="line">// input字符串中lastMatch之后的文本(Opera不支持短属性名）</span><br><span class="line">console.log(RegExp.rightContext); // year!</span><br><span class="line">console.log(RegExp[&quot;$&#x27;&quot;]); // year!</span><br><span class="line"></span><br><span class="line">// 还有9个用来存储捕获组的属性名别是RegExp.$1, RegExp.$2 ... RegExp.$9，调用exec或text函数时这些属性会被自动填充。</span><br><span class="line">console.log(RegExp.$1); // won</span><br><span class="line">console.log(RegExp.$2); // ful</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>String类型中也有一些函数可以使用正则表达式的能力。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>String类型具有match函数，接收一个正则表达式作为参数，如果正则表达式没有g标识时，返回值和调用后RegExp的exec函数相同。在执行match函数后，RegExp函数的input、lastMatch、input、leftContext等静态属性同样会被填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /(.)at/;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches.index); // 0</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // c</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); //</span><br><span class="line">console.log(RegExp.rightContext); // , bat, sat, fat</span><br></pre></td></tr></table></figure><p>当正则表达式中有g标识符并成功匹配的时，match函数返回一个普通数组，里面保存有所有的匹配字串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /(.)at/g;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches); // [ &#x27;cat&#x27;, &#x27;bat&#x27;, &#x27;sat&#x27;, &#x27;fat&#x27; ]</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // bat</span><br><span class="line">console.log(matches[2]); // sat</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); // fat</span><br><span class="line">console.log(RegExp.rightContext); // cat, bat, sat, </span><br></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>String类型search方法接收一个正则表达式参数，如果字符串与正则匹配时，返回第一个匹配的位置，如果不匹配，返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /at/;</span><br><span class="line">console.log(text.search(pattern)); // 1</span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>String类型replace函数可以方便的替换字符串内容并返回替换后的新字符串，该函数接收两个参数。<br>        参数1: 一个字符串或一个正则表达式，使用字符串只能替换第一个匹配项，如果想要替换所有的匹配字串，只能通过传入一个具有g标识的正则表达式<br>        参数2: 一个字符串或一个函数，用来替换匹配的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">console.log(text.replace(&#x27;at&#x27;, &#x27;ond&#x27;)); // cond, bat, sat, fat</span><br><span class="line">console.log(text.replace(/at/g, &#x27;ond&#x27;)); // cond, bond, sond, fond</span><br></pre></td></tr></table></figure><p>当第二个参数为字符串时，还可以使用一些特殊的字符序列,通过这些字符序列，可以使用最后一次匹配结果中的内容。</p><table><thead><tr><th>字符序列</th><th>含意</th></tr></thead><tbody><tr><td>$$</td><td>$</td></tr><tr><td>$&amp;</td><td>匹配整个模式的子字符串，与RegExp.lastMatch的值相同</td></tr><tr><td>$’</td><td>匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</td></tr><tr><td>$&#96;</td><td>匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</td></tr><tr><td>$n</td><td>匹配第n个捕获组的子字符串。其中n为1～99的数字</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">console.log(text.replace(/(.a)(t)/g, &#x27;word ($1$2)&#x27;));</span><br></pre></td></tr></table></figure><p>当第二个参数为函数时，该函数接受的参数依次是 匹配的子串、第一个捕获组、第二个捕获组、 … 、匹配到的子串在原位置的偏移量、被匹配的原字符。该函数需要返回一个字符串类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function htmlEscape(text) &#123;</span><br><span class="line">return text.replace(/[&lt;&gt;&quot;&amp;]/g, function (match, pos, originalText) &#123;</span><br><span class="line">switch (match) &#123;</span><br><span class="line">case &#x27;&lt;&#x27;:</span><br><span class="line">return &#x27;&amp;lt;&#x27;;</span><br><span class="line">case &#x27;&gt;&#x27;: </span><br><span class="line">return &#x27;&amp;gt;&#x27;;</span><br><span class="line">case &#x27;&amp;&#x27;:</span><br><span class="line">return &#x27;&amp;amp;&#x27;;</span><br><span class="line">case &#x27;&quot;&#x27;: </span><br><span class="line">return &#x27;&amp;quot;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(htmlEscape(&#x27;&lt;p class=&quot;greeting&quot;&gt; Hello world! &lt;/p&gt;&#x27;)); // &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt; Hello world! &amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>String类型的split函数可以将一个字符串按指定的切分符切分成一系列的子串并以数组形式返回，该函数第一个参数为分隔符，可以是字符串类型也可以是正则表达式，第二个可选参数是一个整型，用来限制所需要返回数组的最大长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.a/i;</span><br><span class="line">var text = &#x27;my name is NAT&#x27;;</span><br><span class="line">console.log(text.split(pattern)); // [ &#x27;my &#x27;, &#x27;me is &#x27;, &#x27;T&#x27; ]</span><br></pre></td></tr></table></figure><h2 id="ES6变更与新增"><a href="#ES6变更与新增" class="headerlink" title="ES6变更与新增"></a>ES6变更与新增</h2><h3 id="u标识"><a href="#u标识" class="headerlink" title="u标识"></a>u标识</h3><p>在ES6之前字符串都是使用16位（UTF-16）字符编码的，在过去16位足以包含任何字符，直到Unicode引入扩展字符集，字符长度限制在16位将不足以表示这么多的字符，编码规则才不得不进行变更，在UTF-16中前2的16次方个码位均以16位编码单元表示，这个范围被称为基本多文种平面（BMP），超出这个范围的要归属于某个辅助平面，因为其中的码位仅用16位无法表示，UTF-16引入的代理对，其规定使用两个16位编码单元表示一个码位。所以现在的JavaScript字符串中有两种字符，一种是由一个编码单元16位表示的BMP字符，另一种是有32位表示的辅助平面字符。ES5中的对字符串操作都是针对16位编码单元的，如果同样对包含代理对的字符串进行使用，可能结果会与预期不符，正则表达式中新增了u标识来正确匹配包含代理对的字符。同时也为正则表达式增加了unicode属性用来判断正则表达式有没有u标识符。另一新增属性是flags，用于查看正则表达式的所有标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s = &#x27;𠮷&#x27;; // 注意这是一个日语字符，并不是吉利的吉，读音是yoshi（同理，𠮷野家并不读 ’ji ye jia‘，因为第一个字是日文符号，发音是yoshi...）</span><br><span class="line">var pattern = /^.$/;</span><br><span class="line">console.log(pattern.test(s)); // false</span><br><span class="line">console.log(pattern.unicode); // false</span><br><span class="line">console.log(pattern.flags); // </span><br><span class="line"></span><br><span class="line">var pattern = /^.$/u;</span><br><span class="line">console.log(pattern.test(s)); // true</span><br><span class="line">console.log(pattern.unicode); // true</span><br><span class="line">console.log(pattern.flags); // u</span><br></pre></td></tr></table></figure><h3 id="y标识"><a href="#y标识" class="headerlink" title="y标识"></a>y标识</h3><p>ES6新增了y标识，使用y修饰符后，会从正则表达式的lastIndex处开始匹配，匹配失败将不再继续匹配，需要注意的是y标识只对正则表达式的exec和test方法有效，对字符串的方法无效；如果正则表达式中含有^且lastIndex的值不为0时，表达式会永远都不会匹配成功。<br>    可以通过正则表达式的sticky属性来判断表达式是否有y标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;hello hexo.&#x27;;</span><br><span class="line">var pattern1 = /h/g;</span><br><span class="line">console.log(&#x27;sticky&#x27;, pattern1.sticky); // sticky false</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line">pattern1.lastIndex = 2;</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line"></span><br><span class="line">var pattern2 = /h/gy;</span><br><span class="line">console.log(&#x27;sticky&#x27;, pattern2.sticky); // sticky true</span><br><span class="line">console.log(pattern2.test(text)); // true</span><br><span class="line">pattern2.lastIndex = 2;</span><br><span class="line">console.log(pattern2.test(text)); // false</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在ES5中，可以给RegExp构造函数传递一个正则表达式来复制此表达式，如果第一个参数是正则表达式时，不允许有第二个参数，否则会报错，在ES6中，可以给第二个字符类型的参数用作创建的表达式的标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /hello/i;</span><br><span class="line">console.log(pattern.toString()); // /hello/i</span><br><span class="line">console.log(pattern.test(&#x27;Hello world&#x27;)); // true</span><br><span class="line">// 在ES5中会报错，ES6中可以正常执行</span><br><span class="line">var pattern = new RegExp(pattern, &#x27;gmu&#x27;);</span><br><span class="line">console.log(pattern.toString()); // /hello/gmu</span><br><span class="line">console.log(pattern.test(&#x27;Hello world&#x27;)); // false</span><br></pre></td></tr></table></figure><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><h3 id="新增标识"><a href="#新增标识" class="headerlink" title="新增标识"></a>新增标识</h3><p>在ES6之前的运行环境中使用标识u&#x2F;y会导致执行错误，在使用前应该先确认执行环境是否支持u&#x2F;y标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function hasRegExpU() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var pattern = new RegExp(&#x27;.&#x27;, &#x27;u&#x27;);</span><br><span class="line">return true;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hasRegExpU()) &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>在在ES3中使用使用字面量方式创建的正则表达式会共用同一个RegExp实例，在ES5后就没有这一问题了(IE9+);<br>因此ES3中，字面量会使用同一个RegExp实例, 会导致下面两个打印结果是不同的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let regExpression;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">regExpression = /cat/gi;</span><br><span class="line">console.log(regExpression.test(&#x27;catastrophe&#x27;));</span><br><span class="line">&#125;</span><br><span class="line">// 使用new操作符每次创建一个新实例</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">regExpression = new RegExp(&#x27;cat&#x27;, &#x27;gi&#x27;);</span><br><span class="line">console.log(regExpression.test(&#x27;catastrophe&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式的限制"><a href="#正则表达式的限制" class="headerlink" title="正则表达式的限制"></a>正则表达式的限制</h2><ul><li>匹配字符串开始和结尾的\A和\Z锚，但完全支持以插入符（^）和美元符($)来匹配字符串的开始和结尾</li><li>向后查找(lookbehind),但完全支持lookahead</li><li>并集和交集类</li><li>原子组(atomic grouping)</li><li>Unicode支持(单个字符除外，入\uFFFF)</li><li>命名的捕获组，但支持编号的捕获组</li><li>s（single，单行）和x（free-spacing，无间隔）匹配模式</li><li>条件匹配</li><li>正则表达式注解</li></ul><h2 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h2><p>正则表达式的toLocalString() 和 toString() 方法都会返回正则表达式的字面量，与创建方式无关，valueOf函数返回表达式本身</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字符串操作在我们编程中是经常会接触到的，正则表达式是一把操作字符串的利器，我们今天就来罗列一下JavaScript正则相关的api。&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript继承</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/07/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/07/JavaScript%E7%BB%A7%E6%89%BF/</id>
    <published>2019-05-07T14:14:37.000Z</published>
    <updated>2022-06-30T09:25:44.658Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript语言是一种面向对象的语言，所谓的封装、继承、多态等特征JavaScript也都具备，这篇文章中我们就来探讨一下JavaScript中的继承有哪些实现方式。</p><p>如果有java、c++、oc等语言的基础的话会有一种观念，继承是基于与类的，需要说明的是JavaScript中的继承并不是基于类来实现的，而是基于原型的，尽管在ES6中有了class关键字，但在运行时中还是基于原型链来实现的。</p><h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><p>在JavaScript中创建对象典型是通过new操作符来调用构造函数，得到的实例中会有一个[[prototype]]的私有属性，这个私有属性是一个构造函数的prototype属性的一个引用。查找实例属性时会先在自身查找，然后再去查找[[prototype]]，直到查找成功或[[prototype]]为空。这就是原型的基本原理。在ES6之前我们都是通过对构造函数和原型来达到继承的效果。以下我们来列举一下大概会有多少种继承的实践。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>我们知道了对一个对象进行属性查找时如果在自身查找不到时会去原型中进行查找，如果仍然查找不到的话又会继续查找原型的原型，如此反复直至查找成功或没有更深层次的原型可供查找，基于这种原理，我们可以通过将被继承类型的实例作为子类型的原型即是一种实现继承的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">flag</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subflag</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了 Super</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> .<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subflag</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">getSubValue</span>()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 <span class="keyword">instanceof</span> <span class="title class_">SubType</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance1));<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">constructor</span>); <span class="comment">// [Function: SuperType]</span></span><br></pre></td></tr></table></figure><p>根据上面代码可以看出通过将子类型的构造函数的prototype设置为父类型实例，实例化的子类型可以同时拥有子类型和父类型的属性，也就是说我们通过这种方式实现了继承，不过这种继承有一些缺点,原型链中有引用类型的属性时，该属性会被所有实例所共用，这就会造成如果有任何一个实例如果更改了原型中的应用类型的值就会影响到其他实例；再者就是在构造子类型实例时，无法向超类的构造函数中传递参数。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>JavaScript函数有一个call方法，调用时指定的第一个参数为函数的作用域对象，其后参数会作为调用函数的参数进行传递，使用构造函数模式定义的构造函数内部我们会将要定义的属性赋值给作用域对象（this），基于上面两点，我们可以在子类型的构造函数中使用父类型的call函数，把当前的this作为第一个参数传入，以此来获得父类型的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22); </span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">console.log(instance1.name); // Bill</span><br><span class="line">console.log(instance1.age); // 22</span><br><span class="line">console.log(instance1.colors); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">console.log(instance2.name); // Annie</span><br><span class="line">console.log(instance2.age); // 24</span><br><span class="line">console.log(instance2.colors); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance2.sayName); // undefined</span><br><span class="line"></span><br><span class="line">var super1 = new SuperType();</span><br><span class="line">console.log(super1.sayName); // [Function]</span><br></pre></td></tr></table></figure><p>这种方法的优点是，父类型中的引用类型的属性,并不被所有实例所公用，不会有有互相串改数据的问题；在构造子类型的实例时,可以向超类的构造函数中传递参数。不过如果父类型中的函数是定义在父类型实例中的话（典型的构造函数模式就是这样），子类型个实例之间无法复用函数，如果父类型中的函数是定义在父类型原型上的，子类型中根本就继承不到，因为子类型中实例的[[prototype]]是指向子类型的构造函数的prototype的，在子类型实例中没有指向父类型prototype的指针，所以也就没继承到。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合原型链和借用构造函数两者的优点，使用原型链来继承父类型中的原型属性进行继承，使用构造函数对父类型的实例属性进行继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">instance2.sayName(); // Annie</span><br><span class="line">instance2.sayAge(); // 24</span><br><span class="line">console.log(instance2.colors); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof Object); // true</span><br><span class="line">console.log(instance1 instanceof SuperType); // true</span><br><span class="line">console.log(instance1 instanceof SubType); // true</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合了两种模式之后，避免了原型链和借用构造函数的缺陷,融合了他们的优点。成为JavaScript中最常用的继承方式。仅有一点小不足就是调用了两次父类的构造函数,在子类的prototype上面创建了不必要的、多余的属性</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承的原理是将一个对象直接作为新对象的原型，使用这种模式创建的对象并没有自定义的类型，只是实现了在原有对象的基础上进行了扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Bill&quot;,</span><br><span class="line">    friends: [&quot;Annie&quot;, &quot;Frank&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var antherPerson = object(person);</span><br><span class="line">antherPerson.name = &quot;Greg&quot;;</span><br><span class="line">antherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person.name); // Bill</span><br><span class="line">console.log(person.friends); // [ &#x27;Annie&#x27;, &#x27;Frank&#x27;, &#x27;Rob&#x27; ]</span><br><span class="line"></span><br><span class="line">console.log(antherPerson.name); // Greg</span><br><span class="line">console.log(antherPerson.friends); // [ &#x27;Annie&#x27;, &#x27;Frank&#x27;, &#x27;Rob&#x27; ]</span><br></pre></td></tr></table></figure><p>这种模式确实可以创建出基于其他对象的实例，不过在原型链中有引用类型的属性时，该属性会被所有实例所共用;还有一个问题就是在构造子类型的实例时，无法向父类型的构造函数中传递参数。</p><p>在ES5中新增了Object.create函数，该函数规范了原型式继承的，该函数接收两个参数，原型对象以及一个可选的为新对象定义额外属性的属性描述符对象（和Object.defineProperties方法第二个参数一样）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var antherPerson2 = Object.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Frank&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">antherPerson2.friends.push(&quot;Shelby&quot;);</span><br><span class="line">console.log(antherPerson2.name); // Frank</span><br><span class="line">console.log(antherPerson2.friends); // [ &#x27;Annie&#x27;, &#x27;Frank&#x27;, &#x27;Rob&#x27;, &#x27;Shelby&#x27; ]</span><br><span class="line">console.log(antherPerson.friends); // [ &#x27;Annie&#x27;, &#x27;Frank&#x27;, &#x27;Rob&#x27;, &#x27;Shelby&#x27; ]</span><br></pre></td></tr></table></figure><p>总体来说，有了Object.create函数可以是我们更加便捷的使用原型式继承，不过由于引用类型的值会被所有新创建的实例所用，这种模式个人感觉使用时还是需要比较谨慎。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承是将原型式继承使用一个工厂函数将构建过程封装起来，在工程函数中可以为创建的新对象添加所需的新的属性，最后返回新对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">    function object(o) &#123;</span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;</span><br><span class="line">    var clone = object(original);</span><br><span class="line">    // var clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">    clone.sayName = function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, friends) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Bill&quot;, [&quot;Annie&quot;, &quot;Frank&quot;]);</span><br><span class="line"></span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">anotherPerson.sayName(); // Greg</span><br><span class="line"></span><br><span class="line">var anotherPerson1 = createAnother(person);</span><br><span class="line">console.log(anotherPerson.sayName == anotherPerson1.sayName); // false</span><br></pre></td></tr></table></figure><p>这种模式相对于原型模式封装程度更高一点，使用这种模式创建的实例之间不能复用函数，效率会降低。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承是最常用的继承方式，不过他会调用两次父类型的构造函数，形成在实例自身和原型上分别形成一份属性，寄生组合式继承利用构造函数来继承实例属性，通过引用一份父类型引用来获得原型链。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br></pre></td></tr></table></figure><p>寄生组合式继承避免了调用两次父类型的构造函数，避免在子类的prototype上面创建不必要、多余的属性，是ES6之前最理想的继承范式。</p><h2 id="class-extends"><a href="#class-extends" class="headerlink" title="class extends"></a>class extends</h2><p>在ES6之前继承只能通过上面介绍的方法，使用函数，原型，各种组合的手段才能实现较为理想的继承方式，在ES6中JavaScript给出了class和extends操作符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class SuperType &#123;</span><br><span class="line">constructor(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubType extends SuperType &#123;</span><br><span class="line">constructor(name, age) &#123;</span><br><span class="line">// 相当于SuperType.call(this, name);</span><br><span class="line">super(name);</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() &#123;</span><br><span class="line">console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType(&#x27;Bill&#x27;, 25);</span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 25</span><br></pre></td></tr></table></figure><p>在定义SubType时要通过extends指明要继承的父类型，在子类型定义中可是使用super关键字来指示父类型，在constructor中调用super()函数向父类型构造函数传参,这是一个和寄生组合式等价的实现方式,在书写上和语义上都比ES5中要清晰很多，所以建议在实践中应该尽量使用class的extends关键字来实现继承。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript语言是一种面向对象的语言，所谓的封装、继承、多态等特征JavaScript也都具备，这篇文章中我们就来探讨一下JavaScript中的继承有哪些实现方式。&lt;/p&gt;
&lt;p&gt;如果有java、c++、oc等语言的基础的话会有一种观念，继承是基于与类的，需要说明</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://blog.zhanghuiliang.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象创建</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/05/JavaScript%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/05/JavaScript%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/</id>
    <published>2019-05-05T14:21:23.000Z</published>
    <updated>2022-06-30T09:25:44.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>创建一个对象最简单的方法莫过于使用字面量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var animalA = &#123;</span><br><span class="line">name: &#x27;animal&#x27;,</span><br><span class="line">age: 1,</span><br><span class="line">relations: [],</span><br><span class="line">run: function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个animalA对象，他具有三个属性，一个方法。这种创建对象的方法因为简单，所以也是较为常用的一种方法，不过一次只能创建出一个对象，也就是这里的animalA，如果要再次创建一个同样结构的animalB就需要重复写一遍后面的字面量，创建过程不能重用。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是使用一个函数来封装对象的创建过程，每次创建对象是就通过对工厂方法的调用来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createAnimal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = createAnimal(&#x27;animalA&#x27;, 1);</span><br><span class="line">var animalB = createAnimal(&#x27;animalB&#x27;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor, animalB.constructor); // Object() &#123;&#125;, Object() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个createAnimal函数，每次调用即可返回一个具有3个属性，一个方法的对象。工厂模式规避了字面量方式创建相似对象时比较繁琐的问题，但是他没有产生对象类型标示，通过打印animalA和animalB的constructor可以发现输出的都是Object。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>在JavaScript中，可以通过函数名前添加new操作符来创建对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Animal (name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">this.run = function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&#x27;animalA&#x27;, 1);</span><br><span class="line">var animalB = new Animal(&#x27;animalB&#x27;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run); // false</span><br></pre></td></tr></table></figure><p>使用new操作符调用函数时，运行环境会创建一个新对象，然后将构造函数的作用域赋给新对象（this也就指向这个新对象），运行函数，在函数运行结束后如果没有显式的return值，就会将创建的这个新对象作为返回值返回。</p><p>使用构造函数可以重用创建过程，创建的对象具有相同的类型标识（constructor），不过我们对比初始化出的两个实例的run方法会发现它们并不相等，也就是说每次每个实例对象都独立拥有一个自己的run方法，这显然是不够经济且不符合我们对它们的一致性的期望。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>JavaScript函数具有一个prototype属性，使用函数名前加new操作符创建的实例内部会有一个[[prototype]]指针指向构造函数的prototype属性,访问实例的属性时会先对实例自身进行查找，如果查找不到会继续查找实例的[[prototype]]，查找仍然失败就继续查找[[prototype]]的[[prototype]]，依此规则持续进行直到查找成功或失败。所以，将属性放在函数的prototype属性上可以实现实例之间共享数据的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal() &#123;&#125;</span><br><span class="line">Animal.prototype.name = &#x27;&#x27;;</span><br><span class="line">Animal.prototype.age = 0;</span><br><span class="line">Animal.prototype.relations = [];</span><br><span class="line">Animal.prototype.run = function() &#123;</span><br><span class="line">console.log(&quot;run&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal();</span><br><span class="line">var animalB = new Animal();</span><br><span class="line"></span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br><span class="line">console.log(animalA.run === animalB.run); // true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&#x27;fish&#x27;);</span><br><span class="line">console.log(animalA.relations); // [&#x27;fish&#x27;]</span><br></pre></td></tr></table></figure><p>使用原型模式由于所创建的实例的[[prototype]]都指向的是Animal.prototype，所以可以看到他避免了构造函数模式两次创建的实例的run函数不相等的问题，但是原型上的其他引用类型的属性也被共用，因此导致了一个实例更改了原型中引用类型的数据，其他实例访问数据也会变化。</p><h2 id="组合构造函数和原型模式"><a href="#组合构造函数和原型模式" class="headerlink" title="组合构造函数和原型模式"></a>组合构造函数和原型模式</h2><p>仅使用构造函数实例间不能重用函数，仅使用原型模式重用的函数的同时也会导致引用类型的值的重用，因此不难想象我们可以组合使用两者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&#x27;dog&#x27;, 1);</span><br><span class="line">var animalB = new Animal(&#x27;cat&#x27;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&#x27;fish&#x27;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p>组合使用了构造函数模式和原型模式后，解决了对象类型标示问题，可以重用constructor和其他函数,这是一个典型的对象创建的范例。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>构造函数模式和原型模式组合使用后确实是一种不错的实践方式，不过在为构造函数的原型添加函数的代码在构造函数之外，这自然是给人一种封装不足的感觉，我们可以通过在构造函数内部,对函数原型是否已经赋值的判断来动态的添加原型方法,从而实现进一步的封装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">if (!Animal.prototype.run) &#123;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&#x27;dog&#x27;, 1);</span><br><span class="line">var animalB = new Animal(&#x27;cat&#x27;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&#x27;fish&#x27;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p>通过代码可以看到，我们将在原型上添加函数的代码移至函数内部，通过最初的一次判断来确定为原型添加函数的逻辑只会在构造函数第一次被调用时执行。动态原型模式可以理解为是组合构造函数和原型模式的另一种写法。</p><h2 id="寄生构造函数"><a href="#寄生构造函数" class="headerlink" title="寄生构造函数"></a>寄生构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&#x27;dog&#x27;, 1);</span><br><span class="line">var animalB = new Animal(&#x27;cat&#x27;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Object() &#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // false</span><br></pre></td></tr></table></figure><p>寄生构造函数除了使用new操作符调用和把函数叫做构造函数外，看起来跟工厂模式没有任何区别。寄生构造函数模式创建的实例与构造函数的原型属性之间没有关系，所以实例的constructor并不指向构造函数，也无法使用instanceof来判断实例的类型。正常情况下不推荐使用，除非你要为已有类型扩展功能（装潢模式）,比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">var array = new Array();</span><br><span class="line">array.push.apply(array, arguments);</span><br><span class="line">array.toPipedString = function () &#123;</span><br><span class="line">return this.join(&quot;|&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var colors = new SpecialArray(&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;grey&#x27;);</span><br><span class="line">console.log(colors.toPipedString()); // red|blue|grey</span><br></pre></td></tr></table></figure><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>Douglas Crockford发明了JavaScript中的稳妥对象的概念，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象适用于一些安全的环境中（禁止使用new和this），稳妥构造函数和寄生构造函数类似，但有亮点不同，一是新创建对象的实例方法中不使用this，二是不使用new操作符调用构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(name + &#x27; run&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&#x27;dog&#x27;, 1);</span><br><span class="line">animalA.run();</span><br></pre></td></tr></table></figure><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>ES6中新添加了class关键字，可以通过class来定义类，通过对类进行实例化来创建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">constructor(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line">console.log(&#x27;run&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static hello() &#123;</span><br><span class="line">console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Animal); // function</span><br><span class="line">var animalA = new Animal(&#x27;dog&#x27;, 1);</span><br><span class="line">console.log(typeof animalA); // object</span><br><span class="line">console.log(animalA.constructor); // class Animal1&#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br></pre></td></tr></table></figure><p>使用class关键字后面跟类名，跟大括号，在大括号中名为constructor的函数就是构造函数，实例属性可以在constructor中进行初始化，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字面量&quot;&gt;&lt;a href=&quot;#字面量&quot; class=&quot;headerlink&quot; title=&quot;字面量&quot;&gt;&lt;/a&gt;字面量&lt;/h2&gt;&lt;p&gt;创建一个对象最简单的方法莫过于使用字面量：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo使用简介</title>
    <link href="http://blog.zhanghuiliang.cn/2019/04/25/Hexo%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.zhanghuiliang.cn/2019/04/25/Hexo%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2019-04-25T12:54:14.000Z</published>
    <updated>2022-06-30T09:25:44.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进行标记来实现一些页面布局效果的一种方案。一篇Markdown格式的文章写完后，再把Markdown格式转化成html格式的文件用来网站部署，到这里就可以说一下hexo了。</p><p>hexo是一款基于nodejs平台的博客类网站生成工具，使用hexo可以帮我们方便组织我们的Markdown文件、可以帮我们把Markdown格式的文章生成静态html页面、通过插件还可以帮我们把生成的html页面部署到生产环境。</p><p>下面我们就来说一下hexo从安装,到写作,到部署至<a href="https://pages.github.com/">GitHub Pages</a>的过程,由于本文主要是对hexo的简单描述，所以本文章默认你已经安装了nodejs，并且对github有所了解（新建仓库），这里对这些概念不再展开描述了。</p><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>使用hexo之前要先全局安装hexo的命令行工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成hexo之后系统就会有一个hexo的命令行工具可以使用，可以使用下面三行命令来创建hexo’工程’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   # 创建hexo工程,把&lt;folder&gt;替换成你想要的名字</span><br><span class="line"></span><br><span class="line">$ cd &lt;folder&gt;          # 进入工程目录</span><br><span class="line"></span><br><span class="line">$ npm install       # 安装项目依赖</span><br></pre></td></tr></table></figure><p>为了后面的叙述方便，我们需要的一些hexo的插件在这里也一气呵成都安装上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-all-minifier  # 一个可以把生成的网页文件进行压缩，有利于提升网站的访问速度</span><br><span class="line"></span><br><span class="line">$ npm install hexo-deployer-git  # 一个可以帮助我们部署网站的插件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hexo-项目目录结构"><a href="#hexo-项目目录结构" class="headerlink" title="hexo 项目目录结构"></a>hexo 项目目录结构</h2><p>到目前为止，我们的hexo工程已经创建完毕，下面对hexo项目的重要的几个目录以及文件做一下介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml     # 项目的配置文件</span><br><span class="line">public          # 生成的网站文件，稍后部署博客网站也就是部署这个目录中的文件</span><br><span class="line">scaffolds       # 文章模版，创建新文章时可以选择的模版</span><br><span class="line">source          # 存放我们写的文章（Markdown）</span><br><span class="line">  _discarded        # 存放丢弃的文章，理解成垃圾娄把</span><br><span class="line">  _drafts           # 存放草稿，还没有完全写完的文章可以先放在这个目录下</span><br><span class="line">  _posts            # 存放我们要发布的文章，放在这个目录下的Markdown文件稍后都会生成对应的网页</span><br></pre></td></tr></table></figure><h2 id="常用的hexo命令"><a href="#常用的hexo命令" class="headerlink" title="常用的hexo命令"></a>常用的hexo命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;filename&gt;     # 新建一篇文章,layout指scaffolds目录中的模版文件，默认已经有draft、page、post可以选择，如果有需要的话你还可以继续新建模版;新建的文章会放在source/_posts 目录下，有一个例外就是layout设置为draft时文件会放在source/_drafts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo publish [layout] &lt;filename&gt; # 发布草稿，会把source/_drafts目录下的文件转移到source/_posts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo server                      # 开启一个可以预览生成的blog效果的服务。</span><br><span class="line"></span><br><span class="line">$ hexo generate                    # 生成网站，会生成source/_posts目录下文章对应的网页文件，网页文件放在public目录下。</span><br><span class="line"></span><br><span class="line">$ hexo deploy                      # 部署网站,部署方法下面会说</span><br></pre></td></tr></table></figure><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><p>部署网站可以按照自己的喜好部署，在这里给出一种依赖github pages来进行部署的方案，github pages给提供了网站部署功能，使用方法是在github中创建以 ‘用户名.github.io’为名称的一个仓库，然后在这个仓库上传的文件可以通过’用户名.github.io’域名进行访问。创建步骤如下：</p><ol><li>登录 <a href="https://github.com/">github</a>,如果没有账号的话就注册一个</li><li>创建一个git仓库，名称必须是‘&lt;你的github名称&gt;.github.io’</li><li>在仓库页面，点击’clone and downlowd’复制仓库地址，留作稍后部署之用（仓库链接是以.git结尾的那个链接，不是页面浏览器地址框中的链接哈）</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>_config.yml是hexo的配置文件,详细的字段解释在这里也不再赘述，可以看官网的<a href="https://hexo.io/zh-cn/docs/configuration">文档</a>，需要说一下的是关于部署的配置和我们对页面压缩插件的配置，打开_config.yml文件。</p><p>找到deploy选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">把deploy下的type配置为git</span><br><span class="line"></span><br><span class="line">repo 配置为刚才复制的github仓库地址</span><br><span class="line"></span><br><span class="line">配置好后大致长这样：</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/xxxx/xxxx.github.io.git</span><br><span class="line">    branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在页面最底下添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_minifier: true # hexo-all-minifier 插件的配置</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>截止目前为止，我们已经创建并设置好了hexo项目，使用以下两行命令即可完成部署:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate # 生成网站文件</span><br><span class="line">hexo deploy   # 部署网站,第一次会让输入github名称和密码</span><br></pre></td></tr></table></figure><p>部署成功后可以在浏览器中输入 ‘你的github名称.github.io’进行查看部署效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初接触hexo时，需要先进行hexo的安装，和配置，这些都搞定后以后使用中最常做的操作也就是通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &lt;filename&gt; </span><br></pre></td></tr></table></figure><p>创建文章，然后编辑source&#x2F;_post目录下的文章，最后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成网站，并部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://blog.zhanghuiliang.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MacPorts使用简介</title>
    <link href="http://blog.zhanghuiliang.cn/2017/09/08/MacPorts%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.zhanghuiliang.cn/2017/09/08/MacPorts%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2017-09-08T02:34:10.000Z</published>
    <updated>2022-06-30T09:25:44.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.macports.org/">MacPorts</a>是一款供Mac系统的包管理器，主要用来安装软件，卸载软件更新软件等。继续阅读之前需要按照<a href="https://www.macports.org/install.php">官网</a>指示安装MacPorts.</p><p>如果使用官网提供的安装器安装，安装成功后，默认会将MacPorts拷贝到 <em>&#x2F;opt&#x2F;local</em>,执行文件将放在*&#x2F;opt&#x2F;local&#x2F;bin*,其他文件会放在*&#x2F;opt&#x2F;local&#x2F;var&#x2F;macports*,最后会把目录*&#x2F;opt&#x2F;local<em>通过配置文件</em>~&#x2F;.profile*添加到环境变量中(PATH)中。</p><p>可以通过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port version</span><br></pre></td></tr></table></figure><p>port是MacPorts的执行命令,上面的命令可以查看MacPorts的版本，如果成功输出如<em>Version: 2.4.1</em>滋字样，说明MacPorts已经安装成功了，否则就需要检查是否安装失败，或者环境变量添加失败。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>1. 查看帮助</strong><br>可以通过linux man命令查看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ man port</span><br><span class="line">$ man macports.conf</span><br></pre></td></tr></table></figure><p>MacPorts也提供了port help命令查看帮助文档:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看port的帮助文档</span><br><span class="line">$ port help </span><br><span class="line"></span><br><span class="line">其后跟行为参数，可以查看行为的详细介绍，如：</span><br><span class="line">$ port help selfupdate</span><br></pre></td></tr></table></figure><p><strong>2. port selfupdate</strong><br>port命令后跟selfupdate指令可以更新MacPorts、本地Portfiles（保存服务器port信息的数据库）(因此安装成功后就应该检查更新一次)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port selfupdate </span><br></pre></td></tr></table></figure><p>selfupdate后可跟参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>开启debug模式，一旦命令执行错误，可以查看更多详细信息</td></tr><tr><td>–nosync</td><td>只更新MacPorts本身，不更新本地数据库</td></tr></tbody></table><p><strong>3. port diagnose</strong><br>检查运行环境常见问题，把发现的问题都列出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port diagnose </span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–quiet</td><td>只显示警告和错误，不显示执行脚本状态</td></tr></tbody></table><p><strong>4. port reclaim</strong><br>移除不活跃的软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port reclaim</span><br></pre></td></tr></table></figure><p><strong>5. port list</strong><br>列出所有可以通过MacPorts安装的port的列表（不是已安装的列表）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port list</span><br></pre></td></tr></table></figure><p><strong>6. port search</strong></p><p>匹配名称／描述符合关键词的软件，如搜索php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port search php</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–glob</td><td>对给定的搜索字符串作为全局搜索的字符串（即扩展通配符*、？和[字符]。这是默认行为。</td></tr><tr><td>–regex</td><td>将给定搜索字符串视为正则表达式。</td></tr><tr><td>—line</td><td>指定每一个匹配的port信息在一行上输出</td></tr><tr><td>–case-sensitive</td><td>大小写敏感</td></tr><tr><td>field</td><td>测试搜索关键字与指定字段（field）进行匹配，默认匹配字段为 —name —description</td></tr></tbody></table><p>可用的field字段有：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead></table><pre><code>--category, --categories|在指定分类中搜索--depends, --depends_build, --depends_extract, --depends_fetch, --depends_lib, --depends_run |搜索所有依赖名为搜索关键字的port的port，--depends包含其他所有的--depends_ options。--description, --long_description|对port的描述部分进行匹配—homepage|对所有ports的homepage字段进行匹配--maintainer, --maintainers|搜索某个维护者相关的ports—name|只对port的名称进行匹配--portdir|匹配包含在给定目录名下的port--variant, --variants|搜索匹配关键字的变体</code></pre><p><strong>7. port info</strong><br>可以获取软件的信息，如（名称，版本，官网等），如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port info nginx</span><br></pre></td></tr></table></figure><p><strong>8. port deps</strong><br>可以查询软件的依赖</p><p><strong>9. port variants</strong><br>port variants 查询新版本相对于已安装版本的差异</p><p><strong>10. port install</strong><br>安装软件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port install apache2 -preforkmpm +workermpm</span><br></pre></td></tr></table></figure><p>安装apache2，不安装其中的preforkmpm，安装workermpm.<br>如果安装失败可以通过port logfile <portname> 查看日志，sudo port clean <portname>清除安装失败的port。</p><p><strong>11. port clean</strong><br>清理安装过程中所产生的文件，在安装软件失败后经常会用到<br>    sudo port clean <portname></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port clean mysql56</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–archive</td><td>清理临时压缩文件</td></tr><tr><td>–dist</td><td>清理下载的文件</td></tr><tr><td>–logs</td><td>清理日志文件</td></tr><tr><td>–work</td><td>清理安装进程所用目录，此目录是MacPorts构建软件所用，此选项是默认选项。</td></tr><tr><td>–all</td><td>清理所有</td></tr></tbody></table><p><strong>12. port uninstall</strong><br>卸载安装</p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port uninstall &lt;portname&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–follow-dependents</td><td>MacPorts不会卸载还被依赖的port，此选项可以递归卸载安装，比如B 依赖A，卸载A默认是不可以的，使用此选项可以先卸载B，再卸载A。</td></tr><tr><td>–follow-dependencies</td><td>MacPorts不会卸载安装port时所安装的依赖，此选项可以卸载那些被卸载软件的依赖但并没有被其他软件所依赖的软件。</td></tr><tr><td>-f</td><td>(force)，强制卸载port，忽略软件间的依赖关系（尽量不要使用这个选项，除非你特别清楚你所做的操作）</td></tr><tr><td>–no-exec</td><td>卸载时不在触发事件监听，比如卸载时更新本地缓存将不会被执行。</td></tr></tbody></table><p><strong>13. port contents</strong><br>列出所有指定软件的所有安装的文件,此命令经常被用来寻找所安装软件的执行文件路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port  contents &lt;portname&gt; | grep -E &#x27;/s?bin/&#x27;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–size</td><td>列出文件时，同时给出文件大小</td></tr><tr><td>— units ‘UNIT’</td><td>配合—size使用，指定显示文件大小的单位</td></tr></tbody></table><p>‘UNIT’包含以下几种：<br>    B<br>    K, Ki,KiB<br>    Mi,MiB<br>    Gi,GiB<br>    k, kB<br>    M, MB<br>    G, GB</p><p><strong>14. port installed</strong><br>列出已安装的软件及其变体，可以指定软件名，显示与所指定软件相关的安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port installed</span><br></pre></td></tr></table></figure><p>-v显示安装的平台以及CPU等信息</p><p><strong>15. port outdated</strong><br>列出所有版本已旧（已有新版本发布）的软件。</p><p><strong>16. port upgrade</strong><br>更新旧版本的已安装软件及其依赖，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ port upgrade nginx</span><br><span class="line">更新nginx</span><br><span class="line"></span><br><span class="line">$ port upgrade outdated</span><br><span class="line">更新所有旧版本已安装软件及其依赖，</span><br></pre></td></tr></table></figure><p><strong>17. port dependents</strong><br>查询依赖已安装的指定软件的软件,比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ port dependents php56</span><br><span class="line">查询电脑中有哪些软件依赖php56</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt;是一款供Mac系统的包管理器，主要用来安装软</summary>
      
    
    
    
    
    <category term="Mac" scheme="http://blog.zhanghuiliang.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Ajax与跨域</title>
    <link href="http://blog.zhanghuiliang.cn/2017/02/13/Ajax%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>http://blog.zhanghuiliang.cn/2017/02/13/Ajax%E4%B8%8E%E8%B7%A8%E5%9F%9F/</id>
    <published>2017-02-13T12:54:14.000Z</published>
    <updated>2022-06-30T09:25:44.657Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ajax</code>（Asynchronous JavaScript and XML）中文名称：异步JavaScript与XML。由于其可以在不刷新网站页面的的情况下获取新的数据，且还支持同步和异步两种方式（使用方便），而被广泛应用于网站前端，<code>Ajax</code>名称中的XML含义只因XML曾一度是互联网上存储和传输结构化数据的标准，其获取的数据格式不一定是XML。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>在Ajax出现之前，网站需要和后台交互惯用的方法是通过表单提交，在html文件中使用<code>&lt;form&gt;</code>标签，通常一个请求就是一个表单提交。表单提交有一个特点就是，当用户点击‘submit’按钮后（表单提交的请求发出）浏览器就会刷新页面，当前网页不会接收请求的具体结果，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。比如我们经常会遇到的场景，在登录页面，我们输入帐号和密码，点击登录，如果登录成功，页面就会跳转到网站首页或者个人信息页面，如果输入的帐号或者密码是错误的，通常页面会再次跳转到登录页面提示我们帐号错误或者密码错误，需要重新输入，重新登录。</p><p>而当我们有了<code>Ajax</code>之后，我们就可以使用JavaScript发送请求，再由JavaScript更新DOM，用户体验是数据请求时仍然停留在当前页面，但是数据却可以不断地更新。比较典型的例子就是谷歌地图，打开谷歌地图后，我们可以用鼠标拖动地图，然后新的区域的地图在不需要页面刷新的情况下就可以展现出来。</p><p>通过以上对比我们可以看出有了<code>Ajax</code>之后我们的网页的体验，和速度确实增幅不少。用JavaScript写一个完整的<code>Ajax</code>代码并不复杂，在现代浏览器上写Ajax主要依靠XMLHttpRequest对象。</p><p>下面是一个<code>DOM Level 0</code>风格的Ajax的代码，每行代码后面标注了其含义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册请求状态发生变化的回调，状态发生变化时，函数会被调用</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;          <span class="comment">// readyState为4代表请求成功完成</span></span><br><span class="line">        <span class="comment">// 在这里可以执行请求完成的操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">status</span>);         <span class="comment">// status：响应的HTTP状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>);     <span class="comment">// statusText：响应的HTTP状态描述 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);   <span class="comment">// responseText：响应体返回的文本</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseXML</span>);    <span class="comment">// responseXML：如果响应的内容是&quot;text/xml&quot;或&quot;application/xml&quot;，字段的值为包含响应数据的XML DOM文档</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;MyHeader&quot;</span>)); <span class="comment">// getResponseHeader()方法从xhr对象获取响应头部，只要传入获取头部的名称即可</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getAllResponseHeaders</span>());       <span class="comment">// getAllResponseHeaders()方法会返回包含所有响应头部的字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open()方法支持3个参数：请求类型(&quot;get&quot;,&quot;post&quot;,&quot;put&quot;等)、请求URL，以及表示请求是否异步的布尔值。</span></span><br><span class="line"><span class="comment">// URL可以是相对地址也可以是绝对地址，查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有的名/值都必须以&amp;分割</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api?name1=value1&amp;name2=value2&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setRequestHeader方法可以设置请求头，接收两个参数：头部字段的名词和值。为了确保请求头被发送，必须在open()之后、send()之前调用setRequestHeader()</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;MyHeader&#x27;</span>, <span class="string">&#x27;MyValue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义好请求后，必须使用send()方法发送请求</span></span><br><span class="line"><span class="comment">// send()方法接收一个参数，作为请求体发送的数据。</span></span><br><span class="line"><span class="comment">// 如果模拟表单提交，第一步需要设置请求头 Content-Type为&quot;application/x-www-formurlencoded&quot;，数据需要和url的search部分一样组织</span></span><br><span class="line"><span class="comment">// 如果发送JSON数据，需要设置请求头 Content-Type为&quot;application/json&quot;，数据为json格式的字符串</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">// 在收到响应之前如果想要取消异步请求，可以调用abort()方法</span></span><br><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><h4 id="xhr-readyState"><a href="#xhr-readyState" class="headerlink" title="xhr.readyState"></a>xhr.readyState</h4><p>属性有如下可能的值</p><ul><li>0：未初始化（Uninitialized），尚未调用open()方法</li><li>1：已打开（Open）。已调用open()方法，尚未调用send()方法</li><li>2：已发送(Send)。已调用send()方法，尚未收到响应</li><li>3：接收中（Receiving）。已收到部分响应</li><li>4：完成（Complete）。已经收到了所有响应</li></ul><p>对于低版本的IE，需要换一个ActiveXObject对象，其使用方法和XMLHttpRequest一般无二，在这里就不再多举例子。</p><h3 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h3><p><code>XMLHttpRequest Level 1</code>只是把已存在的XHR对象的实现细节明确了一下，<code>XMLHttpRequest Level 2</code>又进一步发展了XHR对象。</p><h4 id="FormData类型"><a href="#FormData类型" class="headerlink" title="FormData类型"></a>FormData类型</h4><p>FormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过直接给FormData构造函数传入一个表单元素，也可以将表单中的数据作为键值对填充进去</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与表单类似格式的数据然后通过XHR发送</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Nicholas&#x27;</span>); <span class="comment">// append()方法接收两个参数：键和值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了FormData实例，可以直接传给xhr对象的send()方法</span></span><br><span class="line">xhr.<span class="title function_">send</span>(data); <span class="comment">// xhr为XMLHttpRequest的实例</span></span><br></pre></td></tr></table></figure><p>使用FormData的另一个方便之处是不再需要给xhr设置任何请求头部了，xhr对象能够识别作为FormData实例传入的数据类型并自动配置响应头部。</p><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p><code>XMLHttpRequest Level 2</code>中规范了xhr对象增加一个<code>timeout</code>属性和<code>timeout</code>事件，给<code>timeout</code>属性设置一个时间（单位ms），且在该时间过后没有收到响应时，xhr对象就会触发<code>timeout</code>事件。</p><h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType()方法"></a>overrideMimeType()方法</h4><p><code>XMLHttpRequest Level 2</code>中规范了xhr对象引入了 overrideMimeType()方法用于重写xhr响应的MIME类型，因为响应返回的MIME类型决定了xhr对象如何处理响应，所以覆盖了响应返回的类型及影响了响应的解析。假设服务器发送了XML数据，但响应头设置了MIME类型是<code>text/plain</code>。结果会导致虽然数据是XML，但responseXML的属性值是null，调用<code>overrideMimeType(&#39;text/xml&#39;)</code>可以保证响应当成XML而不是纯文本处理。</p><p>为了正确覆盖响应的MIME类型，必须在调用send()之前调用overrideMimeType()。</p><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p><code>Progress Events</code>是W3C的工作草案，定义了客户端-服务器端通信。这些事件最初只针对xhr，现在也推广到了其他类似API。有以下6个进度相关的事件。</p><ul><li>loadstart: 在接收到响应的第一个字节时触发</li><li>progress：在接收响应期间反复触发<ul><li><code>onprogress</code>事件处理程序都会收到event对象，其target属性是xhr对象，且包含3个额外属性<ul><li>lengthComputable: 是一个布尔值，表示进度信息是否可用</li><li>position：是接收到的字节数</li><li>totalSize：是响应的Content-Length头部定义的总字节数</li></ul></li><li>为了保证正确执行，必须在调用open()之前添加<code>onprogress</code>事件处理程序</li></ul></li><li>error：请求出错时触发</li><li>abort：在调用abort()终止连接时触发</li><li>load：在成功接收完响应时触发</li><li>loadend：在通信完成时，且在error、abort或load之后触发</li></ul><p>每次请求都会</p><ul><li>首先触发loadstart事件</li><li>之后是一个或多个progress事件</li><li>接着是error、abort或load中的一个</li><li>最后是已loadend事件结束</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><code>Ajax</code>除了使用方便等优点外，也有一些限制，浏览器出于安全考虑有着同源策略，默认只能访问同源的资源。</p><p>同源是指两个页面拥有相同的协议（protocol），和主机(host)，端口（port），那么这两个页面就属于同一个源（origin）。</p><p>完全不允许跨域访问对于web的发展也是一个严重的制约，大约有为以下几种可以实现跨域请求：</p><h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，目前已基本淘汰。</p><h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p><code>图像ping</code>，我们知道，一个网页可以从任何网页中加载图像，没有跨域的限制，因此我们就可以动态的创建图像，使用它们的<code>onload</code>和<code>onerrer</code>事件处理程序来确定是否请求是否完成。</p><p>这种方式多用于与服务器进行简单、单向的跨域通信的一种方式（比如日志上报）。请求的数据是通过查询字符串形式发送的，而响应通常是一个位图图片，或者204的状态码，通过图像ping，浏览器得不到任何具体的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结束&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;http:127.0.0.2:8888/report?function=login&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里创建了一个image的实例，然后注册<code>onload</code>和<code>onerror</code>的监听，这样无论结果如何，只要请求完成，就能得到通知。当我们为img指定src开始，一个带着function＝login参数的请求就被发了出去。</p><p>这种请求方式有两个主要的缺点，一是只能发送GET请求，二是无法访问响应文本。因此只能用于浏览器与服务器间的单向通信。再多分析一下，图像ping实际上是利用了<img>标签可以执行跨域请求的功能，换句话说，是Dom有跨域请求的功能，想明白这一点估计也就能想到，是不是其他的一些需要引用资源的标签是否也可以实现同样的功能，答案是确定的。类似于<code>&lt;img&gt;</code>还有<code>&lt;link&gt;</code>， <code>&lt;video&gt;</code>，<code>&lt;audio&gt;</code>，<code>&lt;object&gt;</code>，<code>&lt;embed&gt;</code>，<code>&lt;applet&gt;</code>，<code>&lt;iframe&gt;</code>等。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>JSONP</code>是”JSON with padding”的简写，是web服务上流行的一种JSON变体。</p><p>以一个场景为例，比如我们需要获取用户的基本信息，假如我们需要获取用户的用户名，性别和年龄三个字段。<br>以接口为<code>http:127.0.0.2:8888/userInfo</code>，我们需要的数据为<code>&#123;&#39;name&#39;:&#39;Ajax&#39;,&#39;sex&#39;:&#39;female&#39;,&#39;age&#39;:&#39;18&#39;&#125;</code>。</p><p><code>JSONP</code>实际上是利用了浏览器允许跨域引用JavaScript资源。 我们需要首先在页面中准备好回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + data.<span class="property">name</span> + <span class="string">&#x27;,i am&#x27;</span> + data.<span class="property">age</span> + <span class="string">&#x27;years old&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建script标签，并将我们需要请求的url后面跟上请求参数<code>callback</code>等于我们预先准备好的回调函数<code>handleCallback</code>，并将script标签插入文档中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">js.<span class="property">src</span> = <span class="string">&#x27;http:127.0.0.2:8888/userInfo?callback=handleCallback&#x27;</span>;</span><br><span class="line">head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>script标签插入文档后，浏览器就会如同加载js代码一样，以<code>get</code>请求的方式去获取src所链接的资源，当后台收到请求后，可以得到请求参数callback的值<code>handleCallback</code>，后台需要将数据包装到<code>handleCallback()</code>中进行返回，看起来和JSON一样，只是被包在一个函数调用里，同时需要Content-type设置为<code>application/javascript </code>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleCallback</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Ajax&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;18&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>当浏览器收到数据后会理所应当的认为返回数据是一段js代码，运行这段代码，恰好就是调用了我们前面预先准备好的函数<code>handleCallback</code>，将我们真正需要传输的数据作为参数传入了回调函数。 这样就完成了跨域加载数据，也是因为<code>JSONP</code>是利用了script标签可以跨域加载资源的这一特点，让请求通过加载脚本的方式进行的，而加载脚本只有<code>get</code>请求一种方式，所以JSONP也只能用使用get请求，并且要求返回数据封装成JavaScript的调用。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨资源共享（CORS）全称<code>Cross-Origin Resource Sharing</code>，规范定义了浏览器与服务器应该如何实现跨源通信。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p><p>比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是<code>text/plain</code>。在发送该请求时，会给它附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是Origin头部的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果服务器认为这个请求可以接受，就在<code>Access-Control-Allow-Origin</code>头部中回发相同的源信息（如果是公共资源，可以回发<code>*</code>）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure><p>如果没有这个头部，或者有这个头部，但源信息不匹配，浏览器则不会响应浏览器请求。</p><p>出于安全考虑，跨域xhr对象存在一些限制</p><ul><li>不能使用setRequestHeader() 设置自定义头部</li><li>请求和响应都不携带cookie</li><li>getAllResponseHeaders()方法始终返回空字符串</li></ul><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>CORS通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部，在发送跨域请求时会向服务器发送一个”预检”请求，这个请求使用OPTIONS方法发送并包含以下头部</p><ul><li>Origin：与请求相同</li><li>Access-Control-Request-Method: 请求希望使用的方法</li><li>Access-Control-Request-Headers:要使用的自定义头部列表(可选，以逗号分隔)</li></ul><p>预检请求发送后，服务器可以确定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器沟通这些信息</p><ul><li>Access-Control-Allow-Origin: 与请求头中的Origin相同</li><li>Access-Control-Allow-Methods: 允许的方法（逗号分隔的列表）</li><li>Access-Control-Allow-Headers: 服务器允许的头部（逗号分隔的列表）</li><li>Access-Control-Max-Age: 预存预检请求的秒数</li></ul><p>预检请求返回后，结果会按照响应中指定的时间缓存一段时间，这段时间内这类请求不需要再额外发送一次HTTP请求。</p><h4 id="凭据请求"><a href="#凭据请求" class="headerlink" title="凭据请求"></a>凭据请求</h4><p>默认情况下，跨源请求不提供凭证（cookie、HTTP认证和客户端SSL证书）。可以通过将xhr的<code>withCredentials</code>设置为true来表明请求会发送凭证。如果服务器允许携带凭证的请求，那么可以在响应中包含如下HTTP头部：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给JavaScript（responseText是空字符串，status是0，onerror()被调用。</p><p>服务器也可以在预检请求的响应中发送这个HTTP头部，已表明这个源允许发送凭据请求。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>用<code>nginx</code>、<code>apache</code>做反向代理，也是一种克服同源策略限制的方式。只需要修改<code>nginx／apache</code>的配置即可解决跨域问题，对于一个服务，可以通过配置多个路径前缀来转发<code>http/https</code>请求到多个目标服务。这个服务器上所有url都是相同的域名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。</p><p>我们拿使用nginx设置反向代理来举一个例子： 假设我们我们当前的站点是<code>www.a.com</code>，我们需要访问的资源是: <code>http://www.b.com/course/api/list</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    server_name www.a.com;</span><br><span class="line">    server_name_in_redirect off;</span><br><span class="line">    root /a;</span><br><span class="line">    location /course/api/list &#123;</span><br><span class="line">        proxy_pass http://www.b.com/course/api/list;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段nginx配置，前6行是一些为了开启<code>www.a.com</code>站点的服务所写，后面的<code>location</code>所包的一段文字就是开启反向代理的配置，在<code>location</code>后面跟的是我们请求的前缀的监测的规则，在这里我们就直接写了<code>/course/api/list</code>，这些配置设置完成后，假如我们想要在<code>www.a.com</code>访问接口<code>http://www.b.com/course/api/list</code> 只需要在<code>www.a.com</code> 中访问 <code>http://www.a.com/course/api/list</code> 即可，当请求发出后，我们的本地服务器（nginx）发现这个接口与我们上面的反向代理的匹配规则能够匹配，就会把我们的请求自动转发到配置中的<code>proxy_pass</code>上，也就是<code>http://www.b.com/course/api/list</code> ，并把请求的response取回来，跨域完成。因为我们的<code>www.a.com</code>发出的请求的域名和协议和端口都和当前站一样，自然就不会有各种跨域的限制，不管是请求方式，还是cookie自然也就可以正常使用。</p><blockquote><p>参考文献：<br>《JavaScript高级程序设计》</p><p>浏览器的同源策略 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a href="http://hayageek.com/cross-domain-Ajax-request-jquery">http://hayageek.com/cross-domain-Ajax-request-jquery</a></p><p><a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a></p><p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000</a></p><p><a href="http://blog.jobbole.com/90975/">http://blog.jobbole.com/90975/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Ajax&lt;/code&gt;（Asynchronous JavaScript and XML）中文名称：异步JavaScript与XML。由于其可以在不刷新网站页面的的情况下获取新的数据，且还支持同步和异步两种方式（使用方便），而被广泛应用于网站前端，&lt;code&gt;Aj</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Compilers</title>
    <link href="http://blog.zhanghuiliang.cn/2017/02/13/Compilers/"/>
    <id>http://blog.zhanghuiliang.cn/2017/02/13/Compilers/</id>
    <published>2017-02-13T12:54:14.000Z</published>
    <updated>2022-06-30T09:25:44.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p>微软出的，通常用于编译Windows应用</p><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>是<code>GNU compiler collection</code>的缩写，是一个编译器集合，包含很多语言的编译器(c,c++,Objective-c,Ada, Fortran, Java). 当你调用<code>gcc</code>时不一定是调用c&#x2F;c++编译器，是gcc根据文件扩展名自动识别并调用对应编译器。</p><h3 id="GCC-x2F-g"><a href="#GCC-x2F-g" class="headerlink" title="GCC&#x2F;g++"></a>GCC&#x2F;g++</h3><p>gcc的 c++ 编译器</p><h2 id="cc"><a href="#cc" class="headerlink" title="cc"></a>cc</h2><p>是来自Unix的c语言编译器，是c compiler的缩写。</p><p>Linux下的<code>cc</code>是<code>gcc</code>的符号链接。可以通过<code>$ls –l /usr/bin/cc</code>来简单察看.而编译时看到的控制台输出<code>CC</code>则是一个指向<code>gcc</code>的变量，该变量是<code>make</code>程序的内建变量，就算你在Makefile中没有<code>CC=</code> ，该变量也会存在，并默认指向<code>gcc</code>。<code>cc</code>的符号链接和变量存在的意义在于源代码的移植性，可以方便的用<code>gcc</code>来编译老的用<code>cc</code>编译的unix软件，甚至连Makefile都不用改。而且也便于Linux程序在unix下编译。</p><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a><a href="https://clang.llvm.org/related.html">clang</a></h2><p>c家族的编译器，兼容<code>gcc</code>，<code>MSVC</code>，目前由苹果公司主导，据说是比<code>gcc</code>更模块化，生成的代码更加优化。</p><ul><li>更快</li><li>更小</li><li>生成代码质量高</li><li>功能更丰富（eg： 用于代码补全）</li></ul><h2 id="Tiny-C-Compiler"><a href="#Tiny-C-Compiler" class="headerlink" title="Tiny C Compiler"></a><a href="https://bellard.org/tcc/">Tiny C Compiler</a></h2><ul><li>小</li><li>快</li><li>生成代码质量一般</li><li>小众，长期不维护，可做学习只用</li></ul><blockquote><p>参考：</p><p><a href="http://www.cnblogs.com/xiedan/archive/2009/10/25/1589462.html">http://www.cnblogs.com/xiedan/archive/2009/10/25/1589462.html</a></p><p><a href="http://xuehanlee.blog.51cto.com/8817835/1397974">http://xuehanlee.blog.51cto.com/8817835/1397974</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MSVC&quot;&gt;&lt;a href=&quot;#MSVC&quot; class=&quot;headerlink&quot; title=&quot;MSVC&quot;&gt;&lt;/a&gt;MSVC&lt;/h2&gt;&lt;p&gt;微软出的，通常用于编译Windows应用&lt;/p&gt;
&lt;h2 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CentOS虚拟机无法连接网络</title>
    <link href="http://blog.zhanghuiliang.cn/2016/12/16/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.zhanghuiliang.cn/2016/12/16/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/</id>
    <published>2016-12-16T07:54:51.000Z</published>
    <updated>2022-06-30T09:25:44.667Z</updated>
    
    <content type="html"><![CDATA[<p> cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</p><p> sudo vim ifcfg-eno16777736</p><p>更改ONBOOT&#x3D;no 为 ONBOOT&#x3D;yes</p><p>重启网络 service network restart</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; cd &amp;#x2F;etc&amp;#x2F;sysconfig&amp;#x2F;network-scripts&amp;#x2F;&lt;/p&gt;
&lt;p&gt; sudo vim ifcfg-eno16777736&lt;/p&gt;
&lt;p&gt;更改ONBOOT&amp;#x3D;no 为 ONBOOT&amp;#x3D;yes&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://blog.zhanghuiliang.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
