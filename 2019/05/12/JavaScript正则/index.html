<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="技术笔记 前端开发"><title>编程小记</title><link rel="stylesheet" href="/styles/layout-bundle.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3ee29108db650b60a69ef622a9cbefeb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="编程小记" type="application/atom+xml"></head><body><div class="main"><link rel="stylesheet" href="/styles/post-bundle.css"><div class="post-page"><h1>JavaScript正则</h1><p class="create-time">发布时间：2019/05/12</p><article class="content"><p>字符串操作在我们编程中是经常会接触到的，正则表达式是一把操作字符串的利器，我们今天就来罗列一下JavaScript正则相关的api。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>JavaScript中提供了字面量和调用RegExp构造函数两种方式来创建正则表达式实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 字面量写法</span><br><span class="line">var expression = / pattern / flags;			</span><br></pre></td></tr></table></figure><p>pattern可以是任何正则表达式(包含字符类、限定符、分组、向前查找、反向引用),模式中使用的所有元字符都必须转义。正则表达式中的元字符包括 ( [ { \ ^ $ | ) ? * + . ] }。flags可取以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g: 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</span><br><span class="line">i: 表示不区分大小写（case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写</span><br><span class="line">m: 表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</span><br><span class="line">u: 支持Unicode扩展字符集的匹配（ES6新增）</span><br><span class="line">y: 影响搜索过程的sticky属性,后面会具体介绍（ES6新增）</span><br></pre></td></tr></table></figure><p>使用构造函数时,第一个参数是字符串类型时，相对于字面量写法，如果有需要转义的字符串，相对于字面量写法需要再多一次转义;如果是一个正则表达式时，会对传入的正则表达式进行复制，在ES6之前，不允许传入第二个参数，否则会发生语法错误，在ES6之后，传入的第二个参数会覆盖原正则表达式的标识符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用构造函数</span><br><span class="line">var expression = new RegExp(pattern, flags) </span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>正则表达式具有一些实例属性，我们可以使用下面的表达式依次尝试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 匹配第一个&#x27;bat&#x27;或&#x27;cat&#x27;,不区分大小写</span><br><span class="line">var pattern2 = /[bt]at/i;</span><br><span class="line"></span><br><span class="line">以下属性都使用此表达式</span><br></pre></td></tr></table></figure><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>可以用来判断正则表达式是否具有g标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;global\t\t&#x27;, pattern2.global); // global		 false</span><br></pre></td></tr></table></figure><h3 id="ignoreCase"><a href="#ignoreCase" class="headerlink" title="ignoreCase"></a>ignoreCase</h3><p>用于判断正则表达式是否具有i标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;ignoreCase\t&#x27;, pattern2.ignoreCase); // ignoreCase	 true</span><br></pre></td></tr></table></figure><h3 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h3><p>用来确定下一次正则匹配的起始位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;lastIndex\t&#x27;, pattern2.lastIndex); // lastIndex	 0</span><br></pre></td></tr></table></figure><h3 id="multiline"><a href="#multiline" class="headerlink" title="multiline"></a>multiline</h3><p>用于判断正则表达式是否具有m标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;multiline\t&#x27;, pattern2.multiline); // multiline	 false</span><br></pre></td></tr></table></figure><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>返回正则表达式的字面量字符, 在ES6之前会返回包括表达式标识完整的字面量，ES6之后，只返回表达式本身，不包含标识（为获取标识提供了单独的flags属性）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;source\t\t&#x27;, pattern2.source); // source		 [bt]at</span><br></pre></td></tr></table></figure><h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><p>属性用来判断正则表达式有没有u标识符 (ES6新增)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;unicode&#x27;, pattern2.unicode); // unicode false</span><br></pre></td></tr></table></figure><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>属性来判断表达式是否有y标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;sticky&#x27;, pattern2.sticky); // sticky false</span><br></pre></td></tr></table></figure><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>用于查看正则表达式的所有标识, （ES6新增）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;flags&#x27;, pattern2.flags); // flags i</span><br></pre></td></tr></table></figure><h2 id="正则表达式函数"><a href="#正则表达式函数" class="headerlink" title="正则表达式函数"></a>正则表达式函数</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>正则表达式exec函数执行后，如果字符串不匹配正则表达式，会返回null，可以匹配的话，会返回一个数组对象，数组的第一项为匹配的字符串，其后为捕获组所捕获的字符串，如果表达式中不含捕获组，数组就只有一项数据，该数组对象相对于普通数组会拥有额外的两个属性index和input，index是字符串中匹配字串首字符的下标，input即被校验的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;mom and dad and baby&#x27;;</span><br><span class="line">var pattern = /mom( and dad( and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">if (matches) &#123;</span><br><span class="line">	console.log(matches.index); // 0</span><br><span class="line">	console.log(matches.input); // mom and dad and baby</span><br><span class="line">	console.log(matches[0]); // mom and dad and baby</span><br><span class="line">	console.log(matches[1]); //  and dad and baby</span><br><span class="line">	console.log(matches[2]); //  and baby</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则中不使用g标志时，每次调用exec函数都会返回第一个匹配项的信息,表达式的lastIndex属性每次都返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /.at/;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 0</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 0</span><br></pre></td></tr></table></figure><p>正则中使用g标志时，每次调用exec后都会返回新的匹配项，直到没有匹配项,表达式的lastIndex属性每次都调用过exec都会增加，变为上次匹配字符的后一字符的下标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.at/g;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &#x27;cat&#x27; 3</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 5 &#x27;bat&#x27; 8</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 10 &#x27;sat&#x27; 13</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 15 &#x27;fat&#x27; 18</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>正则表达式中的test方法接收一个字符串参数，当前模式与参数匹配的话返回true，否则返回false，test方法经常用于只想要检测字符是否符合规则，不关心字符内容的场景，常用于对用户输入进行校验。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;000-00-0000&#x27;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br></pre></td></tr></table></figure><p>值得注意的是，表达式中有g标识时，同exec函数一样，每次执行会从上次匹配结尾处向后继续尝试匹配，完成最后一次匹配后的下一次调用将会返回false，再下一次调用会重新从字符串开始处进行模式匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;bad dad eazy go mad.&#x27;;</span><br><span class="line">var pattern = /.ad/g;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // false</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最后一次正则表达式操作而变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;this is a wonderful year!&#x27;;</span><br><span class="line">var pattern = /(...)der(...)/gi;</span><br><span class="line">if (pattern.test(text)) &#123;</span><br><span class="line">	// 最近一次要匹配的字符串（Opera未实现）</span><br><span class="line">	console.log(RegExp.input); // this is a wonderful year!</span><br><span class="line">	console.log(RegExp.$_); // this is a wonderful year!</span><br><span class="line">	</span><br><span class="line">	// 最近的一次匹配（Opera未实现）</span><br><span class="line">	console.log(RegExp.lastMatch); // wonderful</span><br><span class="line">	console.log(RegExp[&#x27;$&amp;&#x27;]) // wonderful</span><br><span class="line">	</span><br><span class="line">	// 最近一次匹配的捕获组（Opera未实现）</span><br><span class="line">	console.log(RegExp.lastParen); // ful</span><br><span class="line">	console.log(RegExp[&quot;$+&quot;]); // full</span><br><span class="line">	</span><br><span class="line">	// 所有表达式都使用多行模式,boolean类型（nodejs,IE和Opera未实现）</span><br><span class="line">	console.log(RegExp.multiline);</span><br><span class="line">	console.log(RegExp[&#x27;$*&#x27;]);</span><br><span class="line">	</span><br><span class="line">	// input字符串中lastMatch之前的文本(Opera不支持短属性名）</span><br><span class="line">	console.log(RegExp.leftContext); // this is a </span><br><span class="line">	console.log(RegExp[&quot;$`&quot;]); // this is a </span><br><span class="line">	</span><br><span class="line">	// input字符串中lastMatch之后的文本(Opera不支持短属性名）</span><br><span class="line">	console.log(RegExp.rightContext); // year!</span><br><span class="line">	console.log(RegExp[&quot;$&#x27;&quot;]); // year!</span><br><span class="line">	</span><br><span class="line">	// 还有9个用来存储捕获组的属性名别是RegExp.$1, RegExp.$2 ... RegExp.$9，调用exec或text函数时这些属性会被自动填充。</span><br><span class="line">	console.log(RegExp.$1); // won</span><br><span class="line">	console.log(RegExp.$2); // ful</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>String类型中也有一些函数可以使用正则表达式的能力。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>String类型具有match函数，接收一个正则表达式作为参数，如果正则表达式没有g标识时，返回值和调用后RegExp的exec函数相同。在执行match函数后，RegExp函数的input、lastMatch、input、leftContext等静态属性同样会被填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /(.)at/;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches.index); // 0</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // c</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); //</span><br><span class="line">console.log(RegExp.rightContext); // , bat, sat, fat</span><br></pre></td></tr></table></figure><p>当正则表达式中有g标识符并成功匹配的时，match函数返回一个普通数组，里面保存有所有的匹配字串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /(.)at/g;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches); // [ &#x27;cat&#x27;, &#x27;bat&#x27;, &#x27;sat&#x27;, &#x27;fat&#x27; ]</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // bat</span><br><span class="line">console.log(matches[2]); // sat</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); // fat</span><br><span class="line">console.log(RegExp.rightContext); // cat, bat, sat, </span><br></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>String类型search方法接收一个正则表达式参数，如果字符串与正则匹配时，返回第一个匹配的位置，如果不匹配，返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">var pattern = /at/;</span><br><span class="line">console.log(text.search(pattern)); // 1</span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>String类型replace函数可以方便的替换字符串内容并返回替换后的新字符串，该函数接收两个参数。<br>参数1: 一个字符串或一个正则表达式，使用字符串只能替换第一个匹配项，如果想要替换所有的匹配字串，只能通过传入一个具有g标识的正则表达式<br>参数2: 一个字符串或一个函数，用来替换匹配的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">console.log(text.replace(&#x27;at&#x27;, &#x27;ond&#x27;)); // cond, bat, sat, fat</span><br><span class="line">console.log(text.replace(/at/g, &#x27;ond&#x27;)); // cond, bond, sond, fond</span><br></pre></td></tr></table></figure><p>当第二个参数为字符串时，还可以使用一些特殊的字符序列,通过这些字符序列，可以使用最后一次匹配结果中的内容。</p><table><thead><tr><th>字符序列</th><th>含意</th></tr></thead><tbody><tr><td>$$</td><td>$</td></tr><tr><td>$&amp;</td><td>匹配整个模式的子字符串，与RegExp.lastMatch的值相同</td></tr><tr><td>$’</td><td>匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</td></tr><tr><td>$&#96;</td><td>匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</td></tr><tr><td>$n</td><td>匹配第n个捕获组的子字符串。其中n为1～99的数字</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">console.log(text.replace(/(.a)(t)/g, &#x27;word ($1$2)&#x27;));</span><br></pre></td></tr></table></figure><p>当第二个参数为函数时，该函数接受的参数依次是 匹配的子串、第一个捕获组、第二个捕获组、 … 、匹配到的子串在原位置的偏移量、被匹配的原字符。该函数需要返回一个字符串类型的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function htmlEscape(text) &#123;</span><br><span class="line">	return text.replace(/[&lt;&gt;&quot;&amp;]/g, function (match, pos, originalText) &#123;</span><br><span class="line">		switch (match) &#123;</span><br><span class="line">			case &#x27;&lt;&#x27;:</span><br><span class="line">				return &#x27;&amp;lt;&#x27;;</span><br><span class="line">			case &#x27;&gt;&#x27;: </span><br><span class="line">				return &#x27;&amp;gt;&#x27;;</span><br><span class="line">			case &#x27;&amp;&#x27;:</span><br><span class="line">				return &#x27;&amp;amp;&#x27;;</span><br><span class="line">			case &#x27;&quot;&#x27;: </span><br><span class="line">				return &#x27;&amp;quot;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(htmlEscape(&#x27;&lt;p class=&quot;greeting&quot;&gt; Hello world! &lt;/p&gt;&#x27;)); // &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt; Hello world! &amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>String类型的split函数可以将一个字符串按指定的切分符切分成一系列的子串并以数组形式返回，该函数第一个参数为分隔符，可以是字符串类型也可以是正则表达式，第二个可选参数是一个整型，用来限制所需要返回数组的最大长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.a/i;</span><br><span class="line">var text = &#x27;my name is NAT&#x27;;</span><br><span class="line">console.log(text.split(pattern)); // [ &#x27;my &#x27;, &#x27;me is &#x27;, &#x27;T&#x27; ]</span><br></pre></td></tr></table></figure><h2 id="ES6变更与新增"><a href="#ES6变更与新增" class="headerlink" title="ES6变更与新增"></a>ES6变更与新增</h2><h3 id="u标识"><a href="#u标识" class="headerlink" title="u标识"></a>u标识</h3><p>在ES6之前字符串都是使用16位（UTF-16）字符编码的，在过去16位足以包含任何字符，直到Unicode引入扩展字符集，字符长度限制在16位将不足以表示这么多的字符，编码规则才不得不进行变更，在UTF-16中前2的16次方个码位均以16位编码单元表示，这个范围被称为基本多文种平面（BMP），超出这个范围的要归属于某个辅助平面，因为其中的码位仅用16位无法表示，UTF-16引入的代理对，其规定使用两个16位编码单元表示一个码位。所以现在的JavaScript字符串中有两种字符，一种是由一个编码单元16位表示的BMP字符，另一种是有32位表示的辅助平面字符。ES5中的对字符串操作都是针对16位编码单元的，如果同样对包含代理对的字符串进行使用，可能结果会与预期不符，正则表达式中新增了u标识来正确匹配包含代理对的字符。同时也为正则表达式增加了unicode属性用来判断正则表达式有没有u标识符。另一新增属性是flags，用于查看正则表达式的所有标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s = &#x27;𠮷&#x27;; // 注意这是一个日语字符，并不是吉利的吉，读音是yoshi（同理，𠮷野家并不读 ’ji ye jia‘，因为第一个字是日文符号，发音是yoshi...）</span><br><span class="line">var pattern = /^.$/;</span><br><span class="line">console.log(pattern.test(s)); // false</span><br><span class="line">console.log(pattern.unicode); // false</span><br><span class="line">console.log(pattern.flags); // </span><br><span class="line"></span><br><span class="line">var pattern = /^.$/u;</span><br><span class="line">console.log(pattern.test(s)); // true</span><br><span class="line">console.log(pattern.unicode); // true</span><br><span class="line">console.log(pattern.flags); // u</span><br></pre></td></tr></table></figure><h3 id="y标识"><a href="#y标识" class="headerlink" title="y标识"></a>y标识</h3><p>ES6新增了y标识，使用y修饰符后，会从正则表达式的lastIndex处开始匹配，匹配失败将不再继续匹配，需要注意的是y标识只对正则表达式的exec和test方法有效，对字符串的方法无效；如果正则表达式中含有^且lastIndex的值不为0时，表达式会永远都不会匹配成功。<br>可以通过正则表达式的sticky属性来判断表达式是否有y标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;hello hexo.&#x27;;</span><br><span class="line">var pattern1 = /h/g;</span><br><span class="line">console.log(&#x27;sticky&#x27;, pattern1.sticky); // sticky false</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line">pattern1.lastIndex = 2;</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line"></span><br><span class="line">var pattern2 = /h/gy;</span><br><span class="line">console.log(&#x27;sticky&#x27;, pattern2.sticky); // sticky true</span><br><span class="line">console.log(pattern2.test(text)); // true</span><br><span class="line">pattern2.lastIndex = 2;</span><br><span class="line">console.log(pattern2.test(text)); // false</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在ES5中，可以给RegExp构造函数传递一个正则表达式来复制此表达式，如果第一个参数是正则表达式时，不允许有第二个参数，否则会报错，在ES6中，可以给第二个字符类型的参数用作创建的表达式的标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /hello/i;</span><br><span class="line">console.log(pattern.toString()); // /hello/i</span><br><span class="line">console.log(pattern.test(&#x27;Hello world&#x27;)); // true</span><br><span class="line">// 在ES5中会报错，ES6中可以正常执行</span><br><span class="line">var pattern = new RegExp(pattern, &#x27;gmu&#x27;);</span><br><span class="line">console.log(pattern.toString()); // /hello/gmu</span><br><span class="line">console.log(pattern.test(&#x27;Hello world&#x27;)); // false</span><br></pre></td></tr></table></figure><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><h3 id="新增标识"><a href="#新增标识" class="headerlink" title="新增标识"></a>新增标识</h3><p>在ES6之前的运行环境中使用标识u&#x2F;y会导致执行错误，在使用前应该先确认执行环境是否支持u&#x2F;y标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function hasRegExpU() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		var pattern = new RegExp(&#x27;.&#x27;, &#x27;u&#x27;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125; catch (e) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hasRegExpU()) &#123;</span><br><span class="line">//	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>在在ES3中使用使用字面量方式创建的正则表达式会共用同一个RegExp实例，在ES5后就没有这一问题了(IE9+);<br>因此ES3中，字面量会使用同一个RegExp实例, 会导致下面两个打印结果是不同的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let regExpression;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	regExpression = /cat/gi;</span><br><span class="line">	console.log(regExpression.test(&#x27;catastrophe&#x27;));</span><br><span class="line">&#125;</span><br><span class="line">// 使用new操作符每次创建一个新实例</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	regExpression = new RegExp(&#x27;cat&#x27;, &#x27;gi&#x27;);</span><br><span class="line">	console.log(regExpression.test(&#x27;catastrophe&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式的限制"><a href="#正则表达式的限制" class="headerlink" title="正则表达式的限制"></a>正则表达式的限制</h2><ul><li>匹配字符串开始和结尾的\A和\Z锚，但完全支持以插入符（^）和美元符($)来匹配字符串的开始和结尾</li><li>向后查找(lookbehind),但完全支持lookahead</li><li>并集和交集类</li><li>原子组(atomic grouping)</li><li>Unicode支持(单个字符除外，入\uFFFF)</li><li>命名的捕获组，但支持编号的捕获组</li><li>s（single，单行）和x（free-spacing，无间隔）匹配模式</li><li>条件匹配</li><li>正则表达式注解</li></ul><h2 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h2><p>正则表达式的toLocalString() 和 toString() 方法都会返回正则表达式的字面量，与创建方式无关，valueOf函数返回表达式本身</p></article><p class="last-update">最后更新：2022/06/30</p></div><script src="/scripts/post-bundle.js"></script></div><footer class="site-footer"><section><p>欢迎交流</p><address>Email: <a href="mailto:crazyhuiliang@163.com">crazyhuiliang@163.com</a></address><address>Github: <a target="_blank" rel="noopener" href="https://github.com/CrazyHuiLiang">https://github.com/CrazyHuiLiang</a></address></section></footer></body></html>